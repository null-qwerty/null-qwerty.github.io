[{"title":"2025, ciallo～(∠・ω< )⌒★","url":"/2024/12/31/2025-ciallo%EF%BD%9E-%E2%88%A0%E3%83%BB%CF%89-%E2%8C%92%E2%98%85/","content":"首先对不起大萌神，继去年忘记消失日，今年没有卡在消失日的当天看完《凉宫春日的消失》，作为补偿就截出一帧作为本篇文章的封面吧。\n\nps. 发现在盘里放了几年的资源是六声道的，加上 AirPods 爽得飞起pps. SOS 团拍的电影，不管怎么看都是粪作吧（乐\n\n2024 年度总结概览2024 年，没有宇宙人，未来人或者超能力者的出现；没有”键“引发的文明重启；没有因为时间机器的发明导致的第三次世界大战或是 SERN 的理想乡；也没有白色羽毛把熟悉的人带走，是个非常平淡的一年，嗯，就是这样，结束。\n过去的一年，挂两门，依旧没有奖学金，尸体还暖暖的，三战六级，分数还不知道，我猜能过（诶，去年好像也是这么说的）。唯一值得说的就是：我们 RM 终于回到原来国赛守门员的水平了（并不），另外杭电 RM 升 A 类竞赛了，めでたし、めでたし。欢迎看到这篇文章的杭电学弟们报名自动化科协 RM 部，如果到时候还在的话（笑）。\n推 gal 的时间更少了，好多都只推了一半就弃掉了，只有鸟鸟三部曲推完了（真红，嘿嘿，真红），大量的时间花费在 RM 上面，这辈子就给 RM 毁了（雾）。明年总该结束了吧。\nRoboMaster 2024 赛季结束\n参加 RoboMaster 是近年做过最正确的决定，一年的备赛和比赛经历让我学到了非常多的东西。虽然比赛场景仍然算是一个格式化的环境，但比起只是翻翻书做做题要好上太多了。虽然结果有些不尽人意，但没办法，也只能这样了。其他学校也是认认真真备赛一年来参加比赛，这个结果也在预想范围内。\n好像还没说我们今年的成绩，东部赛区十六强，差一场进国赛，差两场进复活赛。换句话说区域赛小组出线，淘汰赛一轮游。\n\n\n感谢华南理工大学华南虎战队制作的赛程分析。\n\nRoboMaster 2025 赛季开始\nRM 有个循环，每年都在从头开始做新的东西，然后赶进度赶进度赶进度，上场半成品，最后遗憾回家。庆幸的是，每年都会有一些学校的一些人尝试打破这个循环，即使大部分都失败了。很荣幸我成为了其中的一员，毕竟：\n忍不了啊，只差一场。\n比赛结束当天是我近几年来第一次流泪。之后每天都在想，如果当时能再逼一把，再多做点事情，把进度赶到前面，是不是就好了。于是我选择今年留队再打一年，希望能把新赛季的进度狠狠抓一把，争取打到深圳。\n不过我并没有对这个赛季有归属感，我认为我的赛季已经结束了，这是学弟的赛季。\n我做的第一件事，是致力于让这个赛季的主力队员能对比赛结果有一种追求，而不仅仅是我一个人希望他们能够打进国赛。毕竟，你不能将自己的愿望强加给别人，这个赛季的队员大概并不能理解我们的心情，也若是强行让他们去达到你的高标准，他们大概率不会认可，还会打击他们的积极性。所以第一步是让他们也有强烈的对好的比赛结果的渴望，让他们自己拥有一个和我们一样的愿望，自然而然地，主动去达成目标。\n我能做的其他事情只有在一些地方督促他们，告诉他们一些可能会出现的问题，尽量给出一个解决方案，并根据结果对人员进行筛选。只做筛选不做教育，这是我这几个月里领悟到的精髓。在此之外给队伍做一些技术积累，以便后续赛季的研发工作。所以这个赛季我不仅在做视觉，机械结构和嵌入式的部分也在做。除了技术工作，这赛季还要做管理、与其他队伍交流、关注赛事信息、大一新生培养等等一系列的工作。\n然而现实给我当头一棒，从 24 年 9 月接手战队管理到现在，遇到了和往年一样的问题：积极性不高，下达的任务无法执行下去，截至目前，进度达到了一个非常诡异的地方：视觉调过车了，但是没多久又调不了了，且出车的进度较去年相比落后了近半个月，时间还在增加中。\n同时规则改动较大，很多东西都要重新设计，去年的技术几乎没有留下，只留下了整车。\n今年和去年的情况估计相差不大，甚至进度上可能更加落后。最后的机会是期末考试结束后，以中期考核为契机，在寒假期间赶一波进度。希望他们能够达到我们去年的水平吧。\n2025 年展望2025 年，希望能把队伍建设的更好，同时能够把学分补回来，并抽出时间考研（我打考研试卷？要上吗？.jpg）。诶有个好消息，下学期好像可以上二休五。\n但是在这之前，先把期末考试熬过去吧。\n最后，祝看到这篇文章的人新年快乐，2025 年多喜乐，长安宁。\n让我们在新的一年里继续传递友谊与爱的魔法吧！\n\n2024 年 12 月 31 日于杭州\n"},{"title":"C 语言基础","url":"/2024/11/01/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/","content":"\n  \n    \n      Note\n\n    \n    \n      本文档用于 HDU-PHOENIX 战队视觉/算法组培训，用于速成 C 语言基础知识。\n本文档仅包含最基础的内容，更多的知识需要自行学习。\n推荐阅读：\n\n《C Primer Plus》\n学校发的 C 语言教材（谭浩强的除外）\n\n\n    \n  \n\n0. C 语言简介C 语言是一种通用的高级编程语言，由美国计算机科学家丹尼斯·里奇（Dennis Ritchie）在 1972 年设计开发。C 语言是一种结构化语言，它的设计目标是提供一种能够以简单的方式编写复杂的程序的语言。\nC 语言是一种面向过程的语言，它的语法结构简单、灵活，同时又具有很强的表达能力，可以直接访问计算机硬件，可以用来编写操作系统、编译器、数据库、网络等系统软件，也可以用来编写应用软件。\nC 语言是一种编译型语言，编译型语言是指程序在运行之前需要先编译成机器码，然后再运行。C 语言的编译器有很多，比如 GCC、Clang、MSVC 等。\nC 语言是一种静态类型语言，静态类型语言是指在编译时就确定了变量的数据类型，变量的数据类型在编译时就已经确定，不会发生变化。\n一个简单的 C 语言程序如下：\n#include &lt;stdio.h&gt;  // 引入头文件，stdio.h 是标准输入输出头文件int main() {    // 主函数，程序从这里开始执行，main 函数是程序的入口，程序必须有且仅有一个 main 函数    printf(\"Hello, World!\\n\");  // 输出 Hello, World!，\\n 表示换行    return 0;   // 返回 0，表示程序正常结束}\n\nprintf 是 C 语言的标准输出函数，用于输出内容到控制台，\\n 表示换行。相对应地，scanf 是 C 语言的标准输入函数，用于从控制台输入内容：\n#include &lt;stdio.h&gt;  // 引入头文件，stdio.h 是标准输入输出头文件int main() {    // 主函数，程序从这里开始执行，main 函数是程序的入口，程序必须有且仅有一个 main 函数    int a;  // 定义一个整数变量 a    printf(\"Please input a number: \");  // 输出提示信息    scanf(\"%d\", &amp;a);  // 从控制台输入一个整数，存入变量 a，%d 表示以整型读入数据，&amp;a 表示变量 a 的地址    printf(\"The number you input is: %d\\n\", a); // 输出变量 a 的值，%d 表示以整型输出数据，\\n 表示换行    return 0;   // 返回 0，表示程序正常结束}\n\n这个程序会提示输入一个整数，然后输出这个整数。\n1. C 语言基本数据类型C 语言的基本数据类型有字符型、整型、浮点型和指针，以下是 C 语言的基本数据类型的长度和能表示的范围：\n\n\n\n类型\n关键字\n格式化输出符\n长度\n所示范围\n\n\n\n字符型\nchar\n%c\n1 Byte, 8bit\n～～\n\n\n无符号字符型\nunsigned char\n%c\n1 Byte, 8bit\n～～\n\n\n短整型\nshort\n%d\n2 Byte, 16bit\n～～\n\n\n无符号短整型\nunsigned short\n%d\n2 Byte, 16bit\n～～\n\n\n整型\nint\n%d\n4 Byte, 32bit\n～～\n\n\n无符号整型\nunsigned int\n%d\n4 Byte, 32bit\n～～\n\n\n长整型\nlong\n%ld\n4 Byte, 32bit\n～～\n\n\n无符号长整型\nunsigned long\n%ld\n4 Byte, 32bit\n～～\n\n\n双长整型\nlong long\n%lld\n8 Byte, 64bit\n～～\n\n\n无符号双长整型\nunsigned long long\n%lld\n8 Byte, 64bit\n～～\n\n\n（单精度）浮点型\nfloat\n%f\n4 Byte, 32bit\n～\n\n\n双精度浮点型\ndouble\n%lf\n8 Byte, 32bit\n～\n\n\n\n  \n    \n      指针\n\n    \n    \n      指针是一个变量，其值为另一个变量的地址。指针的长度取决于操作系统的位数，32 位操作系统的指针长度为 4 Byte，64 位操作系统的指针长度为 8 Byte。举个例子， 32 位操作系统最多只能寻址 4GB 的内存空间。\n\n    \n  \n\n\n定义基本数据类型：\nchar c = 'a';           // 字符型unsigned char uc;       // 无符号字符型short s;                // 短整型unsigned short us;      // 无符号短整型int i = 1;              // 整型unsigned int ui;        // 无符号整型long l;                 // 长整型unsigned long ul;       // 无符号长整型long long ll;           // 双长整型unsigned long long ull; // 无符号双长整型float f = 3.14;         // 单精度浮点型double d;               // 双精度浮点型int *p = &amp;i;            // 整型指针\n\n2. C 语言运算符C 语言的运算符包括算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、三目运算符、逗号运算符、取地址运算符、取值运算符、自增自减运算符、sizeof 运算符、类型转换运算符等。\n2.1 赋值运算符赋值运算符用于给变量赋值，赋值运算符的优先级最低。\nint a = 1;int b = 2;a = b; // a = 2\n\n2.2 算术运算符算术运算符用于进行基本的数学运算。\n\n\n\n运算符\n说明\n示例\n\n\n\n+\n加法\nres = a + b\n\n\n-\n减法\nres = a - b\n\n\n*\n乘法\nres = a * b\n\n\n/\n除法\nres = a / b\n\n\n%\n取模（取余数）\nres = a % b\n\n\n+=\n加法赋值运算符\na += b\n\n\n-=\n减法赋值运算符\na -= b\n\n\n*=\n乘法赋值运算符\na *= b\n\n\n/=\n除法赋值运算符\na /= b\n\n\n%=\n取模赋值运算符\na %= b\n\n\n其中加减法还有自增自减运算符：\n\n\n\n运算符\n说明\n示例\n\n\n\n++\n自增\na++，++a\n\n\n--\n自减\na--, --a\n\n\n例如：\nint a = 1;int b = 2;int res = a + b; // res = 3res = a - b; // res = -1res = a * b; // res = 2res = a / b; // res = 0res = a % b; // res = 1res += a; // 等价于 res = res + ab++; // b = 3--b; // b = 2res = a++; // res = 1, a = 2res = ++a; // res = 3, a = 3res = a--; // res = 3, a = 2res = --a; // res = 1, a = 1\n\n  \n    \n      Note\n\n    \n    \n      使用自增自减运算符的时候需要注意，一条语句中最多使用一个自增或自减运算符，也不要出现 a = a++ 或 a = ++a 这样的语句，例如：\nint i = 1;i = i++ + ++i; // 未定义行为\n以上代码符合语法但是未定义行为，不同编译器可能会有不同的结果。\n\n    \n  \n\n2.3 关系运算符关系运算符用于比较两个值的大小，返回值为真（1）或假（0）。\n\n\n\n运算符\n说明\n示例\n\n\n\n==\n等于\nres = a == b\n\n\n!=\n不等于\nres = a != b\n\n\n&gt;\n大于\nres = a &gt; b\n\n\n&lt;\n小于\nres = a &lt; b\n\n\n&gt;=\n大于等于\nres = a &gt;= b\n\n\n&lt;=\n小于等于\nres = a &lt;= b\n\n\n2.4 逻辑运算符逻辑运算符用于进行逻辑运算，返回值为真（1）或假（0）。\n\n\n\n运算符\n说明\n示例\n\n\n\n&amp;&amp;\n逻辑与\nres = a &amp;&amp; b\n\n\n||\n逻辑或\nres = a|| b\n\n\n!\n逻辑非\nres = !a\n\n\n2.5 位运算符位运算符用于对二进制数进行位运算。\n\n\n\n运算符\n说明\n示例\n\n\n\n&amp;\n位与\nres = a &amp; b\n\n\n|\n位或\nres = a| b\n\n\n^\n位异或\nres = a ^ b\n\n\n~\n位取反\nres = ~a\n\n\n&lt;&lt;\n位左移，第二个数表示位移量\nres = a &lt;&lt; b\n\n\n&gt;&gt;\n位右移，第二个数表示位移量\nres = a &gt;&gt; b\n\n\n&amp;=\n位与赋值运算符\na &amp;= b\n\n\n|=\n位或赋值运算符\na|= b\n\n\n^=\n位异或赋值运算符\na ^= b\n\n\n&lt;&lt;=\n位左移赋值运算符\na &lt;&lt;= b\n\n\n&gt;&gt;=\n位右移赋值运算符\na &gt;&gt;= b\n\n\n例如：\nint a = 3; // 0011_2int b = 2; // 0010_2int res;res = a &amp; b; // 0011_2 &amp; 0010_2 = 0010_2 = 2_10res = a | b; // 0011_2 | 0010_2 = 0011_2 = 3_10res = a ^ b; // 0011_2 ^ 0010_2 = 0001_2 = 1_10res = ~a;    // ~(00000000 00000000 00000000 00000011)_2             // = (11111111 11111111 11111111 11111100)_2             // = -4_10res = a &lt;&lt; b; // 0011_2 &lt;&lt; 2 = 1100_2 = 12_10res = a &gt;&gt; b; // 0011_2 &gt;&gt; 2 = 0000_2 = 0_10\n\n2.6 三目运算符三目运算符用于简化 if-else 语句，语法为 条件表达式 ? 表达式 1 : 表达式 2，如果条件表达式为真则返回表达式 1 的值，否则返回表达式 2 的值。\n例如：\nint a = 1;int b = 2;int res = a &gt; b ? a : b; // res = 2，这是一个获取两个数中较大的数的方法\n\n2.7 逗号运算符逗号运算符用于连接两个表达式，返回值为最后一个表达式的值。\n例如：\nint a = 1;int b = 2;int res = (a++, b++, a + b); // res = 4，逗号运算符会先执行 a++ 和 b++，然后返回 a + b 的值\n\n2.8 取地址运算符和取值运算符（解引用）取地址运算符用于获取变量的地址。\n例如：\nint a = 1;int *p = &amp;a;\n\n取值运算符（解引用）用于获取指针指向的变量的值。\n例如：\n// 接上面的代码int b = *p; // b = 1\n\n2.9 sizeof 运算符sizeof 运算符用于获取变量或类型的长度，返回值为 size_t 类型。\n例如：\nint a = 1;int size = sizeof(a); // size = 4// 等价于// int size = sizeof(int); // size = 4\n\n2.10 类型转换运算符类型转换运算符（强制类型转换、显式类型转换）用于将一个数据类型转换为另一个数据类型。\n强制类型转换的形式为 (type)var，例如：\nint a = 1;double b = (double)a; // b = 1.0\n\n当我们把两个不同类型的数据进行运算时，C 语言会自动进行类型转换（隐式类型转换），将较小的数据类型转换为较大的数据类型，顺序为 char -&gt; short -&gt; int -&gt; long -&gt; long long -&gt; double &lt;- float。而当两个同级别的数据类型进行运算时，C 语言不会将数据类型进行转换。例如：\nint a = 1;double b = 2;double c = a + b; // c = 3.0                  // 计算 a(int) + b(int) 时，结果为 int(3)                  // a + b 结果(3)赋值给 c(double) 时，将 int(3) 隐式转换为 double(3.0)  double d = a / b; // d = 0.0                  // 计算 a(int) / b(int) 时，结果为 int，抹去小数结果为 0                  // a + b 结果(0)赋值给 c(double) 时，将 int 隐式转换为 double(0.0)  d = (double)a / b;  // d = 0.5                    // 强制类型转换后 a(double) / b(int) 隐式转换为 a(double) / b(double) = 1.0 / 2.0 = 0.5                    // 赋值时无转换                    // 手动触发隐式类型转换：乘一个小数d = 1.0 * a / b;    // d = 0.5                    // 1.0(double) * a(int) 转换为 1.0(double) * a(double) = 1.0 * 1.0 = 1.0，结果为 double(1.0)\n\n注意，将一个较大的数据类型转换为较小的数据类型时，可能会造成数据丢失、精度丢失或者溢出。\n\n例如：\n\n将一个浮点数转换为整数时，会将小数部分截断。\n将 double 转换为 float 时，会造成精度丢失。\n\n\n2.11 运算符优先级C 语言的运算符都具有优先级，高优先级先执行，低优先级后执行，同优先级按一定顺序执行，优先级如下表所示：\n\n\n\n优先级\n运算符\n结合顺序\n\n\n\n1\n[], (), ., -&gt;\n从左到右\n\n\n2\n-, ~, ++, –, *, &amp;, !, (type), sizeof\n从右到左\n\n\n3\n/, *, %\n从左到右\n\n\n4\n+, -\n从左到右\n\n\n5\n&lt;&lt;, &gt;&gt;\n从左到右\n\n\n6\n&gt;, &gt;=, &lt;, &lt;=\n从左到右\n\n\n7\n==, !=\n从左到右\n\n\n8\n&amp;\n从左到右\n\n\n9\n^\n从左到右\n\n\n10\n|\n从左到右\n\n\n11\n&amp;&amp;\n从左到右\n\n\n12\n||\n从左到右\n\n\n13\n?:\n从右到左\n\n\n14\n=, /=, *=, %=, +=, -=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^=,|=\n从右到左\n\n\n15\n,\n从左到右\n\n\n3. C 语言保留字（关键字）C 语言的保留字（关键字）是一些具有特殊含义的单词，不能用作变量名、函数名等标识符。除了之前提到的数据类型关键字（如 int、char 等）之外，C 语言还有一些其他的保留字，如下表所示：\n\n\n\n关键字\n说明\n关键字\n说明\n关键字\n说明\n\n\n\n流程控制\n\n存储类说明符\n\ntypedef\n定义类型\n\n\nif\n条件语句\nextern\n外部变量或函数\nvolatile\n不对变量进行优化\n\n\nelse\nif 语句中条件为假时执行的分支\nstatic\n静态变量\n长度计算\n\n\n\nswitch\n多分支条件语句\nregister\n寄存器变量\nsizeof\n计算数据类型长度\n\n\ncase\nswitch 语句中的分支\nauto\n自动变量\n\n\n\n\ndefault\nswitch 语句中的默认分支\n类型限定符\n\n\n\n\n\nfor\nfor 循环\nvoid\n空类型\n\n\n\n\ndo\ndo-while 循环的循环体\nsigned\n有符号数\n\n\n\n\nwhile\nwhile 循环\nunsigned\n无符号数\n\n\n\n\ncontinue\n跳过当前循环的剩余部分\nenum\n枚举类型\n\n\n\n\nbreak\n跳出当前循环或分支\nstruct\n结构体类型\n\n\n\n\ngoto\n跳转到指定标签\nunion\n共用体类型\n\n\n\n\nreturn\n返回函数值\nconst\n常量\n\n\n\n\n加上之前提到的数据类型关键字，C 语言一共有 32 个关键字。\n4. C 语言注释C 语言的注释有两种形式，单行注释和多行注释（块注释）。\n// 这是单行注释，注释内容在 // 后面，直到行尾  /* 这是多行注释   注释内容从 /* 开始   可以跨越多行   直到*\\/结束*/\n\n5. 流程控制C 语言的流程控制有顺序结构、选择结构和循环结构。\n5.1 顺序结构顺序结构是程序按照代码的顺序执行，没有分支和循环。正常情况下，C 语言的代码都是按照顺序结构执行的。\nint a = 1;  // step 1int b = 2;  // step 2int c = a + b;  // step 3\n\n5.2 选择结构选择结构有 if 语句、switch 语句。\n5.2.1 if 语句if 语句用于根据条件执行不同的代码块，语法如下：\nif (condition) {    // 如果 condition 为真，执行这里的代码} else {    // 如果 condition 为假，执行这里的代码}\n\nelse 语句是可选的，可以省略，同时也可以有多个 else if 语句。\n例如：\nint a = 1;int b = 2;if (a &gt; b) {    printf(\"a &gt; b\\n\");} else if (a &lt; b) {    printf(\"a &lt; b\\n\");} else {    printf(\"a = b\\n\");}\n\n5.2.2 switch 语句switch 语句用于根据不同的条件执行不同的代码块，语法如下：\nswitch (expression) {    case constant1:        // 如果 expression == constant1，执行这里的代码        break;    case constant2:        // 如果 expression == constant2，执行这里的代码        break;    ...    default:        // 如果 expression 不等于任何一个 constant，执行这里的代码}\n\nswitch 语句中的 expression 必须是整型或字符型，case 后面的 constant 必须是整型常量或字符常量。\n例如：\nint a = 1;int b = 2;switch (a &gt; b) {    case 1:        printf(\"a &gt; b\\n\");        break;    case 0:        printf(\"a &lt;= b\\n\");        break;    default:        break;}\n\n5.3 循环结构循环结构有 for 循环、while 循环、do-while 循环。\n5.3.1 for 循环for 循环用于重复执行一段代码，一个完整的 for 语句包括初值、条件和增量三部分，语法如下：\nfor (initialization; condition; increment) {    // 第一次执行时执行 initialization    // 如果 condition 为真，执行这里的代码    // 执行完这里的代码后，执行 increment}\n\n例如：\nfor (int i = 0; i &lt; 10; i++) {    printf(\"%d \", i);}\n\n输出：\n0 1 2 3 4 5 6 7 8 9\n\n5.3.2 while 循环while 循环用于重复执行一段代码，语法如下：\nwhile (condition) {    // 如果 condition 为真，执行这里的代码}\n\n例如：\nint i = 0;while (i &lt; 10) {    printf(\"%d \", i);    i++;}\n\n输出：\n0 1 2 3 4 5 6 7 8 9\n\n5.3.3 do-while 循环do-while 循环用于重复执行一段代码，与 while 循环的区别是 do-while 循环会先执行一次循环体，然后判断条件是否为真，语法如下：\ndo {    // 执行这里的代码} while (condition);\n\n例如：\nint i = 0;do {    printf(\"%d \", i);    i++;} while (i &lt; 10);\n\n输出：\n0 1 2 3 4 5 6 7 8 9\n\n5.4 跳转语句C 语言的跳转语句有 break、continue、goto 和 return。\n5.4.1 breakbreak 语句用于跳出当前循环或 switch 语句，程序会继续执行循环或 switch 语句后面的代码。\n例如：\nfor (int i = 0; i &lt; 10; i++) {    if (i == 5) {        break;    }    printf(\"%d \", i);}\n\n输出：\n0 1 2 3 4\n\n5.4.2 continuecontinue 语句用于跳过当前循环的剩余部分，继续执行下一次循环。\n例如：\nfor (int i = 0; i &lt; 10; i++) {    if (i == 5) {        continue;    }    printf(\"%d \", i);}\n\n输出：\n0 1 2 3 4 6 7 8 9\n\n5.4.3 gotogoto 语句用于跳转到指定标签，语法如下：\ngoto label;...label: statement;\n\n例如：\nint i = 0;loop:if (i &lt; 10) {    printf(\"%d \", i);    i++;    goto loop;}\n\n这个代码构成了一个循环。\n5.4.4 returnreturn 语句用于返回函数值，结束函数的执行。\n例如：\nint add(int a, int b) {    return a + b;}\n\n6. 数组与字符串、指针6.1 数组数组是一种存储多个相同类型数据的数据结构，数组的元素可以通过下标访问，数组的下标从 0 开始。\n定义数组语法为 type name[length]，其中 type 是数组元素的类型，name 是数组的名字，length 是数组的长度。\n例如：\nint a[5]; // 定义一个长度为 5 的整型数组int b[] = {1, 2, 3, 4, 5}; // 定义一个长度为 5 的整型数组，并初始化int c[5] = {1, 2, 3, 4, 5}; // 定义一个长度为 5 的整型数组，并初始化float d[3] = {1.1, 2.2, 3.3};char e[5] = {'a', 'b', 'c', 'd', 'e'};\n\n访问数组元素：\nint a[5] = {1, 2, 3, 4, 5};int b = a[0]; // b = 1a[1] = 10; // a = {1, 10, 3, 4, 5}\n\n数组长度是固定的，初始化完成后不能改变。可以通过 sizeof 运算符获取数组的长度。\nint a[5] = {1, 2, 3, 4, 5};int len = sizeof(a) / sizeof(a[0]); // len = 5\n\n遍历一个数组常常使用循环语句。\n数组在内存中是连续存储的，数组变量名其实就是数组首元素的地址。\nint a[5] = {1, 2, 3, 4, 5};int *p = a; // p 指向数组 aint *q = &amp;a[0]; // q 指向数组 a 的首元素// p 和 q 指向的地址是相同的\n\n\n数组元素的下标反应了元素相对于数组首元素的偏移量。\n\n6.2 字符串字符串是一种特殊的字符数组，字符串以 '\\0' 结尾，'\\0' 是字符串结束标志。\n定义字符串语法为 char name[length]，其中 name 是字符串的名字，length 是字符串的长度。使用双引号 \" 来定义字符串常量，字符数组只能在初始化时可以被字符串赋值。在格式化输入输出时，用 %s 表示字符串。\n例如：\nchar str1[6] = {'H', 'e', 'l', 'l', 'o', '\\0'}; // 定义一个字符串，内容为 \"Hello\"// 等价于// char str1[6] = \"Hello\";// 等价于// char str1[] = \"Hello\";char str2[10];// str2 = \"World\"; // 错误，不能直接赋值scanf(\"%s\", str2); // 从控制台输入一个字符串printf(\"%s %s\\n\", str1, str2); // 输出两个字符串\n\n字符串有专门的处理函数，在 string.h 头文件中：\n\n\n\n函数名\n说明\n\n\n\nstrlen(str)\n获取字符串长度，不包括结束标志\n\n\nstrcpy(dest, src)\n复制字符串，将 src 复制到 dest\n\n\nstrcat(dest, src)\n连接字符串，将 src 连接到 dest 后面\n\n\nstrcmp(str1, str2)\n比较字符串，比较 str1 和 str2 的大小，返回值为负数、0 或正数\n\n\nstrchr(str, c)\n查找字符，返回字符串 str 中第一次出现字符 c 的位置\n\n\nstrstr(str1, str2)\n查找字符串，查找字符串 str1 中第一次出现字符串 str2 的位置\n\n\nstrtok(str, delim)\n分割字符串，将字符串 str 按照分隔符 delim 分割\n\n\nsprintf(str, format, …)\n格式化输出到字符串，将格式化输出的结果存入字符串 str\n\n\nsscanf(str, format, …)\n从字符串读取格式化输入，从字符串 str 中读取格式化输入\n\n\n6.3 指针指针是 C 语言的一个重要概念，也是 C 语言特有的东西。指针本质上是一个整型变量，存储的是一个内存地址。\n定义指针语法为 type *name，其中 type 是指针指向的数据类型，name 是指针的名字。使用 &amp; 运算符获取变量的地址，使用 * 运算符获取指针指向的变量的值。\n例如：\nint a = 1;int *p = &amp;a; // 定义一个整型指针 p，指向变量 aint b = *p; // b = 1，获取指针 p 指向的变量的值int *q = NULL; // 定义一个空指针               // NULL 是一个宏定义，表示空指针, 其值是 0printf(\"%d\\n\", *p); // 输出指针 p 指向的变量的值printf(\"%p\\n\", p); // 输出指针 p 的值，十六进制表示\n\n\n数组就是指针，指针就是数组。\n\n使用指针我们可以做一些有趣的事情，例如：\nshort arr[5] = {1, 2, 3, 4, 5};short *p = arr;char *q = (char *)p; // 将 short 指针转换为 char 指针for (int i = 0; i &lt; 5 * 2; i++) {    printf(\"%d \", *(q + i));    // 输出 arr 中每个字节的值}\n\n由于 short 类型占 2 个字节，char 类型占 1 个字节，所以输出的结果是 1 0 2 0 3 0 4 0 5 0。\n\nlinux 系统字节序为小端序（smalldian）。\n\n我们来看另一个例子：\nfloat f = 1.5;int *p = (int *)&amp;f; // 用 int 指针指向 float 变量 fprintf(\"%f\\n\", f); // 输出 f 的值printf(\"%d\\n\", *p);\n\n这个例子中，我们将 float 类型的指针转换为 int 类型的指针，然后输出这两个变量的值，结果是 1.500000 和 1069547520。\n\n  \n    \n      结果解释\n\n    \n    \n      我们来解释一下这个结果。int 和 float 的长度都是 4 个字节，但他们的存储方式不同。4 个字节一共 32 位，最高位是符号位(S)：\n\n对于 int 类型，最高位是符号位，剩下的 31 位是数值位(V)，例如 10 的二进制表示是：\n\n对于 float 类型，最高位是符号位；接下来的 8 位是指数位(E)；最后的 23 位是尾数位(M)，以二进制小数形式存储：\n\n其计算方式为：并规定：\n\n当 E 全为 1 时，表示的是特殊数\n当 M 全为 0 时，表示的是无穷大；\n当 M 不全为 0 时，表示的是 NaN（Not a Number）；\n\n\n当 E 全为 0 时，表示的是非规格化数\n此时 ；\n\n\n当 E 不全为 0 且不全为 1 时，表示的是规格化数，此时 E 取值范围为 1 ~ 254也因此 float 最大取值的绝对值为最小取值（规格化数）的绝对值为所以 1.5 的二进制表示为：\n\n\n这个二进制数转换为十进制数为 1069547520。\n\n    \n  \n\n7. 函数函数表示了一段特定的功能，可以重复调用。函数的定义包括函数名、返回值类型、参数列表和函数体。\n7.1 定义一个函数\n不能在函数内部定义函数，函数的定义必须在函数外部。\n\nreturn_type function_name(parameter_list) {    // 函数体}\n\n其中 return_type 是返回值类型，function_name 是函数名，parameter_list 是参数列表，{} 中是函数体。\n例如：\nint add(int a, int b) {    return a + b;}\n\n函数的声明和定义可以分开，声明函数时只需要写函数的返回值类型、函数名和参数列表，不需要写函数体：\nint add(int a, int b); // 函数声明int main() {    int a = 1;    int b = 2;    int c = add(a, b); // 调用函数    return 0;}int add(int a, int b) { // 函数定义    return a + b;}\n\n编写 C 语言函数要注意以下几点：\n\n函数需要先声明再调用；\n函数不能重名；\n函数的参数个数是任意的；\n函数的参数可以有默认值，有默认值的参数必顫放在参数列表的最后；\n函数可以没有返回值，此时返回值类型为 void，但不建议这样做。\n\n7.2 函数的参数传递函数的参数有两种传递方式：传值和传址。这与函数的调用过程有关。\n7.2.1 传值调用C 语言的函数参数传递是传值的，即将实参的值复制一份给形参，函数内部对形参的修改不会影响实参。\n例如，假设我希望输出函数 y = x + 1，但是我不希望修改 x的值：\n#include &lt;stdio.h&gt;int func(int x) {    // x 是形参，接收实参的值    x = x + 1;  // 修改形参的值    return x;   // 返回修改后的值}int main() {    for(int i = 0; i &lt; 100; i++)        printf(\"%d \", func(i)); // 将 i 的值传递给 x，接收返回值并输出                                // i 的值不会被修改        // 输出：1 2 3 4 5 6 ...    return 0;}\n\n不仅仅传入参数是传值的，函数的返回值也是传值的。函数的返回值是一个临时变量，函数返回后这个临时变量就会被销毁。\n7.2.2 传址调用但是某些情况下，我们希望函数内部对形参的修改能够影响实参，例如下面这个例子：\n#include &lt;stdio.h&gt;int swap(int a, int b) {    // 调用函数时，实参 a 和 b 的值会被复制给形参 a 和 b    // 函数内部交换的是形参 a 和 b 的值    int temp = a;    a = b;    b = temp;    return 0;}int main() {    int a = 1;    int b = 2;    swap(a, b); // a 和 b 作为实参传递给 swap 函数                // 我们希望 a 和 b 的值被交换    printf(\"a = %d, b = %d\\n\", a, b); // 输出 a = 1, b = 2    return 0;}\n\n发现输出结果并不是我们期望的 a = 2, b = 1，这是因为函数参数传递是传值的，函数内部对形参的修改不会影响实参。\n为了解决这个问题，我们可以使用指针来传递参数，这样函数内部对形参的修改就会影响实参。\n#include &lt;stdio.h&gt;int swap(int *a, int *b) {    // a 和 b 是指针，指向实参 a 和 b    // 函数内部交换的是 a 和 b 指向的变量的值    int temp = *a;    *a = *b;    *b = temp;    return 0;}int main() {    int a = 1;    int b = 2;    swap(&amp;a, &amp;b); // a 和 b 的地址作为实参传递给 swap 函数                  // 我们希望 a 和 b 的值被交换    printf(\"a = %d, b = %d\\n\", a, b); // 输出 a = 2, b = 1    return 0;}\n\n严格意义上来说，这个函数依然是传值调用，只不过传递的是指针的值，而不是变量的值。由于指针指向了变量的地址，所以函数内部对指针所指的目标的修改会影响到外部变量。\n7.3 递归函数递归函数是指在函数内部调用自身的函数。递归函数有两个要素：递归边界和递归式。\n例如，计算阶乘的递归函数：\n#include &lt;stdio.h&gt;int factorial(int n) {    if (n == 0) {        return 1; // 递归边界，0! = 1    } else {        return n * factorial(n - 1); // 递归式    }}int main() {    int n = 5;    int result = factorial(n);    printf(\"%d! = %d\\n\", n, result);    return 0;}\n\n递归函数的调用过程如下：\nfactorial(5)5 * factorial(4)5 * 4 * factorial(3)5 * 4 * 3 * factorial(2)5 * 4 * 3 * 2 * factorial(1)5 * 4 * 3 * 2 * 1 * factorial(0)5 * 4 * 3 * 2 * 1 * 15 * 4 * 3 * 2 * 15 * 4 * 3 * 25 * 4 * 65 * 24120\n\n递归函数的优点是代码简洁，但是递归函数的缺点是递归深度过深时会导致栈溢出。\n7.4 函数指针与数据类型一样，函数也具有指针。函数指针是指向函数的指针，函数指针的声明和定义如下：\nreturn_type (*function_pointer)(parameter_list);\n\n其中 return_type 是函数的返回值类型，parameter_list 是参数列表。\n例如：\n#include &lt;stdio.h&gt;int add(int a, int b) {    return a + b;}int sub(int a, int b) {    return a - b;}int mul(int a, int b) {    return a * b;}int div(int a, int b) {    return a / b;}int main() {    int (*func[4])(int, int) = {add, sub, mul, div}; // 定义一个函数指钋数组    int a = 10;    int b = 5;    for (int i = 0; i &lt; 4; i++) {        printf(\"%d\\n\", func[i](a, b)); // 通过函数指针调用函数    }    return 0;}\n\n8. 结构体、联合体和枚举除了基本数据类型，C 语言还提供了结构体、联合体和枚举这三种自定义数据类型。自定义数据类型可以更好地组织数据，提高代码的可读性。\n\n定义自定义数据类型必须在函数外部定义，不能在函数内部定义。\n\n8.1 结构体结构体是一种自定义的数据类型，可以包含多个不同类型的数据。其大小是内部所有成员大小相加。\n结构体的定义如下：\nstruct struct_name {    type1 member1;    type2 member2;    ...};\n\n其中 struct_name 是结构体的名字，member1、member2 是结构体的成员，type1、type2 是成员的数据类型。\n例如，定义一个学生结构体：\nstruct student {    char name[20];    int age;    float score;};\n\n结构体的成员通过 . 运算符访问：\nstruct student s;strcpy(s.name, \"Neri\");s.age = 14;s.score = 90.5;\n\n如果结构体的成员是指针，则通过 -&gt; 运算符访问：\nstruct student *p = &amp;s;strcpy(p-&gt;name, \"Neri\");p-&gt;age = 14;p-&gt;score = 90.5;// 等价于strcpy((*p).name, \"Neri\");(*p).age = 14;(*p).score = 90.5;\n\n8.2 联合体联合体是一种特殊的结构体，联合体的所有成员共用同一块内存，联合体的大小等于最大的成员的大小。联合体的定义如下：\nunion union_name {    type1 member1;    type2 member2;    ...};\n\n例如，定义一个共用体：\nunion data {    int i;    float f;};\n\n联合体的访问与结构体类似，通过 . 或 -&gt; 运算符访问。\nunion data d;union data *p = &amp;d;d.f = 1.5;printf(\"%d\\n\", d.i); // 输出 1069547520printf(\"%f\\n\", p-&gt;d); // 输出 1.500000\n\n8.3 枚举枚举是一种自定义的数据类型，枚举的成员是常量，枚举的定义如下：\nenum enum_name {    member1,    member2,    ...};\n\n例如，定义一个颜色枚举：\nenum color {    RED,    GREEN,    BLUE};\n\n此时 RED、GREEN、BLUE 是常量，其值分别为 0、1、2。\n规定后一个枚举成员的值比前一个枚举成员的值大 1，如果需要指定枚举成员的值，可以在定义时赋值：\nenum color {    RED = 2,    // RED = 2    GREEN = 5,  // GREEN = 5    BLUE        // BLUE = 6};\n\nenum color {    RED = 1,    GREEN = 2,    BLUE = 4};\n\n枚举的成员可以通过枚举名访问：\nenum color {    RED,    GREEN,    BLUE};// ...省略部分代码...enum color c = RED;printf(\"%d\\n\", c); // 输出 0// ...省略部分代码...\n","tags":["C/C++"]},{"title":"Cloudflare国内访问慢的原因和解决方法","url":"/2024/01/31/Cloudflare%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"\n  \n    笔者最终 使用了 Cloudflare 的 SaaS 服务。\n\n  \n\n减速 CDN虽然 Cloudflare 提供全球 CDN 服务，但是在国内访问的速度非常慢，常被戏称为“减速 CDN”。原因在于，对来自中国大陆的访问，Cloudflare 会将其路由到位于美国的服务器，导致访问速度异常的慢。\n至于为什么路由到美国而不是更近的新加坡、日本、中国香港等地，大概是因为亚洲的网络线路的费用更贵吧（）\n实际上 Cloudflare 和百度云（后面好像换成了京东云）有合作，在中国有 CDN 服务器的，但这是一种定制服务，作为个人是无法使用的。\n\n不过我们可以使用别的一些方法自选服务器地址使在中国大陆的访问更快。\nCloudflareSpeedTest在查阅资料时笔者发现了 CloudflareSpeedTest 这个仓库，他可以返回当前网络连接下，延迟最低的 Cloudflare 服务器。\n既然我已经有了 CDN 服务器的 IP，那么我就可以选择这个 CDN 服务器提供服务。\n配置自选 IP网上查到的方法首先使用 CloudflareSpeedTest 测速，找到延迟最低的 Cloudflare CDN 服务器 IP。例如，笔者在杭州移动网络下测到的 IP 如下：\n\n之后，将域名的 DNS 服务器改成非 Cloudflare 的 DNS 服务器，如笔者改回了阿里云分配的万网 DNS：\ndns27.hichina.comdns28.hichina.com\n\n并在解析中添加 A 记录指向上面测出的低延迟服务器 IP 即可。\n\n当然也可以只加一部分。\n但是，一段时间过后会收到 Cloudflare 发送的邮件：\n\nxxx 的名称服务器不再指向 Cloudflare。它们现在指向：\ndns27.hichina.comdns28.hichina.com[not set]\n此更改意味着 xxx 不再使用 Cloudflare……\n\n也就是你没有使用 Cloudflare 的 DNS，需要把 DNS 服务器换到它给你的那两个重新开启 Cloudflare 服务。但这么做太麻烦了。笔者尝试过将 Cloudflare 的 DNS 和万网 DNS 同时设置，以及在 DNS 解析中添加 NS 记录指向 Cloudflare DNS，都无法解决这个问题。\n修改后的方法考虑到这个博客的访问几乎都来自国内，实际上不用考虑来自国外的访问。所以做出以下改动。\n前两步与上面相同，测速并添加 A 记录，但是 DNS 不动，保持使用 Cloudflare DNS。\n随后，在 Cloudflare 的 DNS 解析记录中添加 NS 记录：\n\n对于普通的网站上面方法是可行的，但需要加非常多条 NS 记录，需要把所有子域名都添加 NS 记录指向万网 DNS。但由于笔者使用过 Cloudflare Worker，导致部分子域名无法指向万网 DNS，后续便换回前一种方法。\n使用 Cloudflare SaaS由于上述方法在使用过程中并未解决问题，笔者在网上找到了使用 Cloudflare SaaS 的方法。目前笔者正在使用这种方法，效果挺好。\n准备工作\nSaaS 虽然有免费方案，但仍然需要一个支付方式，如果没有海外银行卡可以使用 Paypel。\n准备第二个域名，用于解析到 Cloudflare SaaS 的 IP。\n\n\n笔者这里使用原域名 null-qwerty.top 作为回退源，新域名 null-qwerty.work 使用阿里云 DNS 解析到 Cloudflare 的自定义主机名。\n\n启用 SaaS新建 DNS 记录 cname.yourdomain.com 指向需要回退的地址。这里笔者的网站和服务均部署在 vercel 上，所以指向 vercel 的 IP。\n\n注意这条记录需要开启 Cloudflare 的代理。\n配置 SaaS左侧打开 SSL/TLS -&gt; 自定义主机名，先将刚刚添加的 cname.yourdomain.com 填到回退源中，然后添加新的自定义主机名。\n\n添加自定义主机名需要在新域名的 DNS 中添加验证，添加一条 TXT 记录即可：\n\n添加完验证记录，再添加一条 CNAME 记录指向回退源：\n\n配置完成。\n\n解释通过 CNAME 的方式指向 Cloudflare 而非固定 IP，这样可以利用 Cloudflare 的泛播自动找到最快的边缘服务器（虽然仍在海外），大大增加了访问速度。相比与上一种方法来说，这种方法更加稳定，而且步骤也更少。\n\n  \n    笔者在测试的时候发现，移动网络下大概率会解析失败，但是联通和电信网络下都能正常解析。这个问题可能是由于移动网络中 Cloudflare 的泛播地址(1.1.1.1) 被占用导致的。仍需进一步测试。\n\n  \n\n","tags":["Cloudflare"]},{"title":"LaTeX表达式","url":"/2023/10/06/LaTeX%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"字母a b c d e f g h i j k l m n o p q r s t u v w x y zA B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\n\n\n\n\n希腊字母小写/大写\nLaTeX形式\n希腊字母小写/大写\nLaTeX形式\n\n\n\n\n\\alpha A\n\n\\mu N\n\n\n\n\\beta B\n\n\\xi \\Xi\n\n\n\n\\gamma \\Gamma\n\no O\n\n\n\n\\delta \\Delta\n\n\\pi \\Pi\n\n\n\n\\epsilon \\varepsilon E\n\n\\rho \\varrho P\n\n\n\n\\zeta Z\n\n\\sigma \\Sigma\n\n\n\n\\eta H\n\n\\tau T\n\n\n\n\\theta \\vartheta \\Theta\n\n\\upsilon \\Upsilon\n\n\n\n\\iota I\n\n\\chi X\n\n\n\n\\lambda \\Lambda\n\n\\psi \\Psi\n\n\n上标\n\n\n符号\nLaTeX形式\n符号\nLaTeX形式\n\n\n\n\n\\hat{a}\n\n\\widehat{a}\n\n\n\n\\ddot{a}\n\n\\dot{a}\n\n\n\n\\bar{a}\n\n\\check{a}\n\n\n\n\\vec{a}\n\n\\tilde{a}\n\n\n\n\\grave{a}\n\n\\acute{a}\n\n\n\n\\breve{a}\n\n\\widetilde{a}\n\n\n\n\\overline{a}\n\n\\sim\n\n\n符号\n\n\n符号\nLaTeX形式\n符号\nLaTeX形式\n\n\n\n\n\\times\n\n\\div\n\n\n\n\\bigcap_1^6\n\n\\bigcap_{1}^{n}\n\n\n\n\\bigcup_1^6\n\n\\bigcup_{1}^{n}\n\n\n\n\\binom53\n\n\\binom{5}{3}\n\n\n\n\\forall\n\n\\exists\n\n\n\n\\partial\n\n\\propto\n\n\n\n\\left\\{ \\right \\}\n\n\\left \\langle \\right \\rangle\n\n\n\n\\sqrt{100}\n\n\\sqrt[3]{1000}\n\n\n\n\\mathop{\\lim}_{n \\to \\infty }f(x)\n\n\\frac{3}{7}\n\n\n\n\\sum_{n=0}^{\\infty}\n\n\\int_a^bf(x)dx\n\n\n\n\\int\n\n\\oint\n\n\n\n\\oiint\n\n\\oiiint\n\n\n矩阵# 矩阵的输入，其中\"\\cdots\"为省略号，\"\\newline\"为换行，\"&amp;\"为对齐符号A_{m,n} = \\begin{pmatrix}a_{1,1} &amp; a_{1,2} &amp; \\cdots &amp; a_{1,n} \\newlinea_{2,1} &amp; a_{2,2} &amp; \\cdots &amp; a_{2,n} \\newline\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots    \\newlinea_{m,1} &amp; a_{m,2} &amp; \\cdots &amp; a_{m,n} \\end{pmatrix}\n\n\n方程/方程组i\\hbar\\frac{\\partial}{\\partial t}\\psi=-\\frac{\\hbar^2}{2m}\\nabla^2\\psi+V\\psi\n\n\n# 麦克斯韦方程组\\begin{cases}{}\\oint_l{Hdl}=\\int_s{jds}+\\int_s{\\frac{\\partial D}{\\partial t}ds} \\newline\\oint_l{Edl}=-\\int_s{\\frac{\\partial B}{\\partial t}}\\newline\\oint_s{ds}=0 \\newline\\oint_s{Dds}=\\int_v{\\rho dv}\\end{cases}\n\n\n","tags":["数学","LaTeX"]},{"title":"Linux下基于UNIX域套接字的进程间通信","url":"/2023/12/13/Linux%E4%B8%8B%E5%9F%BA%E4%BA%8EUNIX%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","content":"UNIX 域套接字（UDS）是一种常用的进程间通信（IPC）的方法，相较于 tcp&#x2F;udp 套接字，它更适合同一台机器的进程间通信，也只能在同一台机器上实现通信。\nUNIX 域套接字地址UNIX 域套接字使用 struct sockaddr_un 结构体来表示地址，它的定义如下：\nstruct sockaddr_un&#123;    sa_family_t sun_family;    char sun_path[108];&#125;\n\n其中 sun_family 域的值为 AF_UNIX，sun_path 域的值为套接字文件在文件系统中的路径，该路径的长度不能超过 sizeof(sun_path)，即 108 - 1 = 107 个半角字符。\n创建 UNIX 域套接字UNIX 域套接字的创建与 tcp&#x2F;udp 套接字类似，只是在调用 socket() 函数时，第一个参数为 AF_UNIX，第二个参数为 SOCK_STREAM 或 SOCK_DGRAM。\nint unixfd_stream = socket(AF_UNIX, SOCK_STREAM, 0);   // 流 socketint unixfd_dgram = socket(AF_UNIX, SOCK_DGRAM, 0);     // 数据报 socket\n\n在查询这两种套接字的区别时，在 stackoverflow 上找到这么一段解释：\n\nA stream socket is like a phone call – one side places the call, the other answers, you say hello to each other (SYN&#x2F;ACK in TCP), and then you exchange information. Once you are done, you say goodbye (FIN&#x2F;ACK in TCP). If one side doesn’t hear a goodbye, they will usually call the other back since this is an unexpected event; usually the client will reconnect to the server. There is a guarantee that data will not arrive in a different order than you sent it, and there is a reasonable guarantee that data will not be damaged.\nA datagram socket is like passing a note in class. Consider the case where you are not directly next to the person you are passing the note to; the note will travel from person to person. It may not reach its destination, and it may be modified by the time it gets there. If you pass two notes to the same person, they may arrive in an order you didn’t intend, since the route the notes take through the classroom may not be the same, one person might not pass a note as fast as another, etc.\n\n个人认为，stream socket 更适合做同步通信，而 datagram socket 更适合做异步通信。\n绑定 UNIX 域套接字使用 bind 函数将套接字与地址绑定。绑定时，bind 会在指定的路径下创建一个文件用于标识该套接字，文件与套接字是一一对应的关系。\nstruct sockaddr_un addr;addr.sun_family = AF_UNIX;  // 类型strcpy(addr.sun_path, &quot;/tmp/uds_socket&quot;);   // 地址int unixfd = socket(AF_UNIX, SOCK_STREAM, 0);   // 创建套接字if(bind(unixfd, (struct sockaddr*)&amp;addr, sizeof(addr)) == -1)   // 绑定，发生错误时返回 -1&#123;    perror(&quot;bind error&quot;);    exit(1);&#125;\n绑定后，可使用 getsockname 获取文件的路径。\n若不再使用该套接字，可使用 unlink 删除该文件，但是在删除文件前，必须先关闭套接字，否则会导致文件无法删除。\n使用流套接字进行进程间通信的实例服务端首先创建一个 UNIX 域套接字，使用 bind 绑定到一个路径上，调用 listen 监听该套接字，然后调用 accept 接收客户端的连接请求，最后使用 read 读取客户端发送的数据。\n#include &lt;sys/socket.h&gt;#include &lt;sys/un.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define BUF_SIZE 1024int main()&#123;    struct sockaddr_un addr;    // 地址    addr.sun_family = AF_UNIX;    strcpy(addr.sun_path, &quot;/tmp/uds_socket&quot;);    int unixfd = socket(AF_UNIX, SOCK_STREAM, 0);   // 创建套接字    if(bind(unixfd, (struct sockaddr*)&amp;addr, sizeof(addr)) == -1)   // 绑定到地址    &#123;        perror(&quot;bind error&quot;);        exit(1);    &#125;    if(listen(unixfd, 5) == -1) // 监听，最多允许 5 个连接    &#123;        perror(&quot;listen error&quot;);        exit(1);    &#125;    int clientfd = accept(unixfd, NULL, NULL);  // 接收连接请求，返回客户端的文件描述符    if(clientfd == -1)    &#123;        perror(&quot;accept error&quot;);        exit(1);    &#125;    char buf[BUF_SIZE];    int n;    while((n = read(clientfd, buf, BUF_SIZE)) &gt; 0)  // 读取客户端发送的数据    &#123;        buf[n] = &#x27;\\0&#x27;;        printf(&quot;receive: %s\\n&quot;, buf);    &#125;    // 关闭打开的文件    close(clientfd);    close(unixfd);    unlink(&quot;/tmp/uds_socket&quot;);    return 0;&#125;\n\n客户端客户端的代码比服务端简单，只需要创建一个 UNIX 域套接字，然后使用 connect 连接到服务端，最后使用 write 向服务端发送数据。\n#include &lt;sys/socket.h&gt;#include &lt;sys/un.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define BUF_SIZE 1024int main()&#123;    struct sockaddr_un addr;    // 地址    addr.sun_family = AF_UNIX;    strcpy(addr.sun_path, &quot;/tmp/uds_socket&quot;);    int unixfd = socket(AF_UNIX, SOCK_STREAM, 0);   // 创建套接字    if(connect(unixfd, (struct sockaddr*)&amp;addr, sizeof(addr)) == -1)   // 连接到服务端    &#123;        perror(&quot;connect error&quot;);        exit(1);    &#125;    char buf[BUF_SIZE];    while(fgets(buf, BUF_SIZE, stdin) != NULL) // 从标准输入读取数据    &#123;        int n = strlen(buf);        if(write(unixfd, buf, n) != n)  // 发送数据到服务端        &#123;            perror(&quot;write error&quot;);            exit(1);        &#125;    &#125;    // 关闭打开的文件    close(unixfd);    return 0;&#125;\n运行结果：\n注意事项运行程序时必须先运行服务端，再运行客户端，否则客户端会报错 connect error: No such file or directory。原因是客户端在连接时，会检查指定的路径是否存在，先运行服务端才能创建指定文件。\n若不加其他方法，服务端只能处理一个客户端的连接请求，即一对一的通信，若要实现一对多，可使用 epoll 或 select 来实现，之后会介绍。\n","tags":["Linux","Socket"]},{"title":"TestPage","url":"/2024/01/11/TestPage/","content":"音乐播放器\nvar meting_api='https://api.null-qwerty.work/Meting?server=:server&type=:type&id=:id&r=:r';\n\n\n使用APlayerJS和MetingJS，需要对APlayer插件进行修改，使其支持夜间模式。笔者改的非常简单，修改颜色的 alpha 值，使其透明。另外把自建的Meting API放在这：https://api.null-qwerty.work/Meting\n视频播放器onedrive\n    \n\n\n使用 onedrive 作为视频存储，获取直链后用video标签进行播放。\ngithub 视频床\n\n\n  var video = document.getElementById('video');\n  if(Hls.isSupported()) {\n  var hls = new Hls();\n  hls.loadSource('https://cdn.jsdelivr.net/gh/null-qwerty/videos@main/test/index.m3u8');\n  hls.attachMedia(video);\n} else if (video.canPlayType('application/vnd.apple.mpegurl')) {\n  video.src = 'https://cdn.jsdelivr.net/gh/null-qwerty/videos@main/test/index.m3u8';\n}\n\n\n使用ffmpeg将视频切片，每个片段最好不超过 20M。画质可能会有所下降，跟所设码率有关。使用github作为视频存储。使用hls.js播放m3u8格式的视频。cloudflare workers 要骂娘，请求次数巨高不仅白嫖github，还白嫖cloudflare，真香\n"},{"title":"Hello World","url":"/2023/10/04/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"git 安装与使用","url":"/2024/10/17/git-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"\n  \n    本文中开发环境为 ubuntu 24.04，其他系统的安装可能会有所不同，仅供参考。\n\n  \n\n为什么使用 gitgit 是一个分布式版本控制系统，可以有效的管理代码，方便团队协作，提高开发效率。在开发过程中，我们经常会遇到以下问题：\n\n代码丢失\n代码冲突\n代码版本混乱\n代码备份不及时\n代码合并困难\n\n等等，这些问题都可以通过 git 来解决。\n安装 git与大多数软件一样，我们可以使用 apt 来安装 git：\nsudo apt install git -y\n\n安装完成后，可以使用以下命令查看 git 的版本：\ngit --version\n\n输出：\ngit version 2.43.0\n\n配置 git安装完成后，我们需要配置 git，配置的内容包括用户名和邮箱：\ngit config --global user.name &quot;yourname&quot;git config --global user.email &quot;email@example.com&quot;\n\n其中 --global 表示全局配置，如果只想对当前仓库配置，可以去掉 --global，这样只对当前仓库生效。一般情况下，我们都是全局配置。\ngit 基本操作\n  \n    git 练习网站\n\n  \n创建仓库在本地创建一个新的仓库，可以使用以下命令：\ngit init\n\n这个命令会在当前目录下创建一个 .git 文件夹，这个文件夹是 git 用来管理版本的核心。\n克隆仓库如果我们想要克隆一个远程仓库到本地，可以使用以下命令：\ngit clone &lt;url&gt;\n\nurl 是远程仓库的地址，可以是 https 或者 ssh 协议。\n例如：\ngit clone https://github.com/null-qwerty/null-qwerty.git\n\n会将我的 github 主页克隆到本地。\n添加文件在 git 中，我们需要将修改过的文件添加到暂存区，然后再提交到仓库。添加文件到暂存区可以使用以下命令：\ngit add &lt;filename&gt;\n\n如果想要添加所有文件，可以使用：\ngit add .\n\nfilename 可以是文件名，也可以是目录名，可以使用通配符。\n提交文件将暂存区的文件提交到仓库，可以使用以下命令：\ngit commit -m &quot;message&quot;\n\nmessage 是提交的信息，可以是任意字符串，一般情况下，我们会写上这次提交的内容。如果不加 -m 参数，会进入一个编辑器，让我们输入提交信息。\n提交规范请参考commit 规范。\n\n  \n    提交信息是必须的，如果不写提交信息，会提交失败。\n\n  \n\n撤销提交如果我们提交了错误的代码，或者想要撤销提交，可以使用以下命令：\ngit reset --hard &lt;commit&gt;\n\ncommit 是提交的哈希值，可以使用 git log 查看，也可以填写分支名。\n查看状态查看当前仓库的状态，可以使用以下命令：\ngit status\n\n这个命令会显示当前仓库的状态，包括已修改的文件，已暂存的文件，未跟踪的文件等。\n查看单个文件的修改情况，可以使用：\ngit diff &lt;commit&gt; &lt;filename&gt;\n\ncommit 是提交的哈希值，可以使用 git log 查看，也可以填写分支名，filename 是文件名。\n比较两个提交之间的差异，可以使用：\ngit diff &lt;commit1&gt; &lt;commit2&gt;\n\n查看提交记录查看提交记录，可以使用以下命令：\ngit log\n\n这个命令会显示当前仓库的提交记录，包括提交者，提交时间，提交信息等。\n分支操作在 git 中，分支是一个非常重要的概念，我们可以使用分支来进行并行开发，版本控制等。\n分支操作中有以下几个重要的概念：\n\nHEAD：指向当前分支的指针\norigin：远程仓库\nbranch：分支\n\n查看当前分支，可以使用：\ngit branch\n\n这个命令会显示当前仓库的所有分支，当前分支会有一个 * 标记。\n创建分支，可以使用：\ngit branch &lt;branchname&gt;\n\nbranchname 是分支名。\n切换分支，可以使用：\ngit checkout &lt;branchname&gt;\n\n合并分支，可以使用：\ngit merge &lt;branchname&gt;\n\n会将 branchname 分支合并到当前分支。\n删除分支，可以使用：\ngit branch -d &lt;branchname&gt;\n\n远程操作在 git 中，我们可以将本地仓库推送到远程仓库，也可以从远程仓库拉取代码。\n推送代码到远程仓库，可以使用：\ngit push origin &lt;branchname&gt;\n\n这条命令会将当前分支暂存的提交推送到远程仓库的 branchname 分支。如果不填写 branchname，会将当前分支推送到远程仓库的当前分支，此时可以简写为git push;如果远程仓库没有当前分支，会自动创建。\n\n  \n    请注意，推送代码到远程仓库是一个危险的操作，一定要谨慎操作。\n\n  \n\n\n  \n    禁止使用 git push -f，这个命令会强制推送代码，会覆盖远程仓库的代码。\n\n  \n\n拉取代码，可以使用：\ngit pull origin &lt;branchname&gt;\n\n这条命令会将远程仓库的 branchname 分支拉取到本地仓库。如果不填写 branchname，会拉取远程仓库的当前分支，此时可以简写为git pull。\n拉取代码时，本地暂存区不能有未提交的修改，否则会拉取失败。可以使用 git stash 命令将本地暂存区的修改暂存起来，合并之后再使用 git stash pop 恢复。\ntag 操作在 git 中，我们可以使用 tag 来标记一些重要的提交，例如版本发布等。\n创建 tag，可以使用：\ngit tag &lt;tagname&gt;\n\ntagname 是 tag 的名字。git 会默认将 tag 标记在最新的提交上，并自动创建一个轻量标签。\n如果想要在之前的提交上创建 tag，可以使用：\ngit tag &lt;tagname&gt; &lt;commit&gt;\n\ncommit 是提交的哈希值。\n查看 tag，可以使用：\ngit tag\n\n这个命令会显示当前仓库的所有 tag。\n删除 tag，可以使用：\ngit tag -d &lt;tagname&gt;\n\n.gitignore 文件在 git 中，我们可以使用 .gitignore 文件来忽略一些文件，这些文件不会被 git 管理。\n例如，在项目根目录下创建一个 .gitignore 文件，在文件中写入：\nbuild/*.log\n\n这样，build 目录和所有的 .log 文件都不会被 git 管理，不会被提交到仓库。\n我们建议将项目的构建目录、日志文件、临时文件、IDE 配置文件和大型文件等都加入到 .gitignore 文件中。\n如果你在之前已经提交了这些文件，且已经提交到远端，可以使用以下命令修改提交：\ngit filter-branch --force --index-filter &#x27;git rm --cached --ignore-unmatch &lt;filename&gt;&#x27; --prune-empty --tag-name-filter cat -- --all\n\n命令解释：fliter-branch：过滤分支，用于修改提交历史。--force：强制执行。--index-filter：修改索引，用于修改文件。&#39;git rm --cached --ignore-unmatch &lt;filename&gt;&#39;：删除文件。--prune-empty：删除空提交。--tag-name-filter cat：修改 tag。-- --all：修改所有分支。\n其中 filename 是文件名或文件夹，可以使用通配符。\n\n  \n    该操作极其危险，会修改提交历史，若无必要请不要在多人协作的项目中使用。\n\n  \n\n使用 vscode 进行 git 操作vscode 内置的 git 插件提供了图形化的界面，方便我们进行 git 操作。可对照上面的命令学习使用，这里不再赘述。\n连接到 github在使用 git 的过程中，我们经常会使用 github 来托管代码，这里简单介绍一下如何连接到 github。\n由于目前 github 已经不再支持密码登录，有两种方式连接，下面一一介绍。\n使用 ssh key 连接首先，我们需要生成 ssh key：\nssh-keygen -t rsa -b 4096 -C &quot;\n\n这个命令会在 ~/.ssh 目录下生成一个 id_rsa 和 id_rsa.pub 文件，id_rsa 是私钥，id_rsa.pub 是公钥。\n然后，我们需要将公钥添加到 github 上，打开 github，点击右上角的头像，选择 Settings，然后选择 SSH and GPG keys，点击 New SSH key，将公钥粘贴到 Key 中，点击 Add SSH key。\n接下来，我们需要测试一下是否连接成功：\nssh -T git@github.com\n\n如果连接成功，会显示 Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access.。\n之后在使用过程中，将远程仓库地址改为 ssh 协议即可。\n使用 token 连接首先，我们需要在 github 上生成一个 token，打开 github，点击右上角的头像，选择 Settings，然后选择 Developer settings，点击 Personal access tokens，点击 Generate new token，填写 Note，选择 repo 权限，为了方便也可以把权限全部勾选，点击 Generate token，将生成的 token 复制下来。\n\n  \n    token 只有一次复制机会，请妥善保管 token，且不要泄露给他人。\n\n  \n\n然后，我们需要将 token 添加到 git 的凭证管理器中：\ngit config --global credential.helper store\n\n然后在登录时使用 token 替换密码，提交到 https 协议的远程仓库。用户名和密钥会保存在 ~/.git-credentials 文件中。\n\n  \n    不推荐使用 token 连接，因为 token 有时效性，且泄露后会造成安全问题。\n\n  \n\ncommit 规范在多人协作的项目中，commit 规范是非常重要的，可以提高代码的可读性，方便团队协作。规范的提交信息应该包括以下几个部分：\n\ntype：提交的类型。\nscope：提交的范围，可以是文件名，模块名等。\nsubject：提交的主题，简短描述这次提交的内容。\nbody：提交的详细内容，可以包括修改的原因，解决的问题等。\nfooter：提交的备注，可以包括关联的 issue，关闭的 issue 等。\nbreaking change：提交的破坏性变更，可以包括 API 的变更，配置的变更等。\n\n模板如下：\ntype(scope): subjectbodyfooter\n\n\n  \n    \n      type 的类型\n\n    \n    \n      \nfeat：新功能，指新增了一个功能。\nfix：修复 bug，指修复了一个 bug。\nbreak: 破坏性变更，指修改了 API，配置等。\ndocs：文档更新。\nstyle：格式化代码，不影响代码逻辑。\nrefactor：重构代码，既不新增功能，也不修复 bug。\ntest：测试，包括单元测试，集成测试等，不影响代码逻辑。\nchore：构建工具，依赖管理等，不影响代码逻辑。\nperf：性能优化，提高代码性能。\nrevert：回滚，撤销之前的提交。\nmerge：合并，合并分支。\nrelease：发布，发布新版本。\ndeps：依赖更新，更新依赖包。\n\n\n    \n  \n\n每次提交尽量做到单一功能，不要将多个功能放在一个提交中，这样可以方便代码的维护和回滚。\n例如：\nfeat(core): add new featureadd new feature to core moduleclose #123BREAKING CHANGE: change the API of core module\n\n建议仅将源文件提交到仓库，其他文件如编译生成的文件、依赖库等不要提交到仓库，用 .gitignore 文件来忽略这些文件或文件夹。\n","tags":["git"]},{"title":"markdown语法","url":"/2023/10/06/markdown%E8%AF%AD%E6%B3%95/","content":"标题# 一级标题## 二级标题### 三级标题#### 四级标题......\n\n斜体/加粗/删除线*斜体***加粗*****斜体加粗***~~删除线~~\n\n斜体\n加粗\n斜体加粗\n删除线\n引用&gt; 一级引用 &gt; 一级引用 &gt;&gt; 二级引用 &gt;&gt; 二级引用 &gt;&gt;&gt; 三级引用 &gt;&gt;&gt; ...\n\n\n一级引用一级引用\n\n二级引用二级引用\n\n三级引用…\n\n\n\n链接![图片描述](path/to/image.jpg)[链接描述](https://example.com)\n\n\n星空鉄道とシロの旅\n代码块`代码片段`\n\nC语言中格式化输出函数是 printf()\n``` 语言代码块```\n\n#include &lt;iostream&gt;int main(){    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;    return 0;}\n\n分割线**** * *---- - -____ _ _\n\n效果相同\n\n\n\n\n\n\n列表无序表* 无序* 无序* 无序\n\n等同于\n+ 无序+ 无序+ 无序\n\n等同于\n- 无序- 无序- 无序\n\n\n无序\n无序\n无序\n\n有序表1. 有序2. 有序3. 有序\n\n\n有序\n有序\n有序\n\n复选框- [ ] 未选- [x] 已选\n\n\n 未选\n 已选\n\n表格| 表头1 | 表头2 | 表头3 || ----- | ----- | ----- || 内容1 | 内容2 | 内容3 || 内容4 | 内容5 | 内容6 |\n\n\n\n\n表头1\n表头2\n表头3\n\n\n\n内容1\n内容2\n内容3\n\n\n内容4\n内容5\n内容6\n\n\nLaTeX表达式使用一对 $ 或一对 $$ 括起来。\n语法见 LaTeX表达式\n","tags":["markdown"]},{"title":"ubuntu 下 CubeMX + cmake + gcc-arm-none-eabi + ozone 开发环境搭建","url":"/2024/10/03/ubuntu-%E4%B8%8B-CubeMX-cmake-gcc-arm-none-eabi-ozone-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"\n  \n    本文使用的开发板为 RoboMaster 开发板 C 型，其芯片为 STM32F407IG，开发环境为 ubuntu 24.04。\n\n  \n\nJ-Link 驱动安装安装 J-Link 驱动首先下载 J-Link 驱动的依赖 libreadline 库：\nsudo apt-get install libreadline-dev\n\n在 SEGGER 官网下载 J-Link 驱动，选择 Linux 版本的 deb 安装包\n\n会有一些跳转，根据引导走就行了。下载完成后，使用 dpkg 安装：\nsudo dpkg -i JLink_Linux_Vxxx_x86_64.deb\n\n驱动程序将被安装到 /opt/SEGGER/JLink 目录下，同时会在 /etc/udev/rules.d 目录下生成一个 99-jlink.rules 文件，用于配置 J-Link 的权限。将 JLink 目录添加到环境变量中：\necho &#x27;export PATH=$PATH:/opt/SEGGER/JLink&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc\n如果使用的是 zsh，将 ~/.bashrc 替换为 ~/.zshrc 即可。\n验证 J-Link 驱动使用如下命令验证 J-Link 驱动是否安装成功：\njlink --version\n如果安装成功，会显示 J-Link 的版本信息。\nJ-Link 接 C 板，插入 J-Link\n\n然后执行以下命令：\nJLinkExe\n\n提示输入 connect，并输入芯片型号，这里输入 STM32F407IG，然后选择 SWD，speed 可以使用默认的 4000kHz,如下图所示则连接成功。\n\nCubeMX 安装在 ST 官网下载 CubeMX，选择 Linux 版本的安装包，下载完成后解压。\n\n\n  \n    笔者在使用 6.12.1 版本时，JxBrowser Engine 在刚打开 CubeMX 的时候直接报 crash 导致窗口无法正常打开，切换至 6.11.1 版本后问题解决。\n\n  \n\n  \n    2025.3.3 更新：更新至 6.14.0 版本后问题解决。\n\n  \n\n解压后进入文件夹，执行 ./SetupSTM32CubeMX-x.xx.x 安装 CubeMX，根据提示安装即可。\n打开 CubeMX，登录账号，登录后点击 INSTALL/REMOVE 安装 STM32F4 芯片包。\n\n新建工程先安装 gcc-arm-none-eabi 工具链：\nsudo apt install gcc-arm-none-eabi\n\n打开 CubeMX，新建工程，选择芯片型号，这里选择 STM32F407IGHx，点击 Start Project，打开 Project Manager，选择 Toolchain/IDE 为 CMake，点击 Generate Code。\n\n在项目根目录打开 vscode，Core/Src/main.c 就是主函数所在的文件:\n\n发现静态分析崩了，原因是使用了 clangd 进行了静态分析，在没有编译过的情况下，clangd 无法找到头文件，所以会报错。这里 cmake 一下就好了。\nmkdir buildcd buildcmake ..\n\n\nclangd 的配置可以看这里。\n在根目录创建 .JLinkScripts 文件，内容如下：\nspeed 4000device STM32F407IGrloadfile ./JLink-test.elfq\n其中 JLink-test.elf 为编译生成的 elf 文件，路径相对于 Makefile 文件。\n在 CMakelists.txt 中添加如下内容：\nadd_custom_command(OUTPUT flash    COMMAND JLinkExe -if SWD -CommanderScript $&#123;CMAKE_SOURCE_DIR&#125;/.JLinkScripts)add_custom_target(Flash DEPENDS flash)\n这样在执行 make Flash 的时候就会自动烧录。\ncd buildcmake ..make -jmake Flash\n\n\nozone 安装及使用在 SEGGER 官网下载 ozone，选择 Linux 版本的安装包，下载完成后使用 dpkg 安装。\n\n安装完成后，使用如下命令启动 ozone：\nozone\n\n这里使用一个蜂鸣器工程为例。\n插上 J-Link,连接 C 板，打开 ozone,选择 STM32F407IG, svd 文件在如图所示的路径下：\n\nTarget Interface 选择 SWD，然后选择底下识别到的 J-Link:\n选择需要调试的 elf 文件：\n第四页可以保持默认，然后点击 Finish，就可以开始调试了：\n点击左上角的绿色图标开始调试，再点击右边的继续按钮，程序就会开始运行，直到遇到断点。\n在 watch data 中可以添加需要监视的变量，如下图所示，并绘制出变量的变化曲线。\n\n其他功能可以自行探索。\n效果\n\n\n  var video = document.getElementById('video');\n  if(Hls.isSupported()) {\n  var hls = new Hls();\n  hls.loadSource('https://videos.null-qwerty.work/stm32haruhikage/index.m3u8');\n  hls.attachMedia(video);\n} else if (video.canPlayType('application/vnd.apple.mpegurl')) {\n  video.src = 'https://videos.null-qwerty.work/stm32haruhikage/index.m3u8';\n}\n\n","tags":["stm32","vscode","cmake"]},{"title":"ubuntu18.04下使用php+mysql+apache的网站搭建","url":"/2023/10/12/ubuntu18-04%E4%B8%8B%E4%BD%BF%E7%94%A8php-mysql-apache%E7%9A%84%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/","content":"\n  \n    如果我做错了什么，请让法律来制裁我，而不是让我用php写项目\n\n  \n最近在给社团网站做服务器迁移，遇到了一些问题，记录一下。\n\n系统环境\n\nubuntu18.04\n\n\n安装|配置 MySQL安装使用 apt-get 安装\nsudo apt-get updatesudo apt-get install mysql-server   # 安装 mysql 服务端\n\n配置MySQL初始化安全脚本\nsudo mysql_secure_installation\n\nmysql_secure_installation中会有设置root密码，删除匿名用户，禁止root远程登录，删除test数据库，刷新权限表等操作，可以全都选择yes。root密码看情况更改。\n配置完成后，可以使用以下命令查看MySQL服务状态\nsudo systemctl status mysql.service\n\n会产生类似如下输出（此处的输出并非在配置结束后运行产生的，仅作参考）\n● mysql.service - MySQL Community Server   Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled)   Active: active (running) since Thu 2023-10-12 00:26:53 CST; 13h ago Main PID: 657 (mysqld)    Tasks: 28 (limit: 2333)   CGroup: /system.slice/mysql.service           └─657 /usr/sbin/mysqld --daemonize --pid-file=/run/mysqld/mysqld.pid\n\n进入MySQL\nsudo mysql -u root -p\n\n创建新用户\nCREATE USER &#x27;newuser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27;;\n\n给新用户并授权\nGRANT ALL PRIVILEGES ON *.* TO &#x27;newuser&#x27;@&#x27;localhost&#x27; ;\n\n刷新权限表（一定要记得刷新）\nFLUSH PRIVILEGES;\n\n创建新数据库，给网站使用\nCREATE DATABASE newdatabase;\n\n使用新数据库\nUSE newdatabase;\n\n退出MySQL\nexit\n\n安装|配置 php安装建议使用源码编译安装。获取源码包\ncurl -o php-7.4.33.tar.gz https://www.php.net/distributions/php-7.4.33.tar.gztar -zxvf php-7.4.33.tar.gzcd php-7.4.33\n\n配置安装内容按需求配置安装内容，这里只是一个示例，具体安装内容可以参考官方文档。\n./configure --prefix=/usr/local/php --sysconfdir=/etc/php --with-openssl --with-zlib --with-bz2 --with-curl --enable-bcmath --enable-gd --with-webp --with-jpeg --with-mhash --enable-mbstring --with-imap-ssl --with-mysqli=mysqlnd --enable-exif --with-ffi --with-zip --enable-sockets --with-pcre-jit --enable-fpm --enable-pdo --with-pdo-mysql=mysqlnd --with-mysql=mysqlnd --enable-pcnt\n\nmysqlnd是php提供的mysql驱动，是php5.3之后才有的。此处不选择mysql驱动之后会出错。\n配置过程中可能会出现一些错误，根据错误提示安装相应的依赖即可。\n编译安装\nmakesudo make install\n\n安装完成后执行以下命令\nsudo cp php.ini-development /etc/php/php.ini # 复制配置文件模板ln -s /usr/local/php/bin/php /usr/bin/php   # 建立软链接ln -s /usr/local/php/bin/phpize /usr/bin/phpizeln -s /usr/local/php/sbin/php-fpm /usr/bin/php-fpm\n\n然后执行以下命令，查看php版本\nphp -v\n\n配置修改php配置文件\nsudo vim /etc/php/php.ini\n\n添加pdo_mysql扩展\nextension=pdo       ; 添加pdo扩展extension=mysqlnd   ; 添加mysqlnd扩展，因为前面设置pdo_mysql驱动为mysqlndextension=pdo_mysql ; 添加pdo_mysql扩展\n\n修改完后退出保存，重启php-fpm\nsudo systemctl restart php-fpm\n\n安装|配置 apache安装使用 apt-get 安装\nsudo apt-get install apache2sudo apt-get install libapache2-mod-php\n\n安装完成后启动apache\nsudo systemctl start apache2\n\n配置修改apache配置文件\nsudo vim /etc/apache2/apache2.conf\n\n添加如下内容\n&lt;Directory /var/www/html&gt;    Options Indexes FollowSymLinks    AllowOverride All    Require all granted&lt;/Directory&gt;\n\n修改完后退出保存，重启apache\nsudo systemctl restart apache2\n\n执行以下命令，启动rewrite模块\nsudo a2enmod rewrite\n\n在 /var/www/html 目录下创建 index.php 文件，输入以下内容\n&lt;?phpphpinfo();?&gt;\n创建.htaccess文件，输入以下内容\n&lt;IfModule mod_rewrite.c&gt;RewriteEngine onRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]&lt;/IfModule&gt;\n\n然后在浏览器中输入 http://localhost ，如果出现php信息页面，说明apache和php都安装成功了。可以用此页面查看php的配置信息。随后即可在该路径下放置网页文件。\n设置域名在 /etc/apache2/sites-available 目录下创建 example.com.conf 文件，输入以下内容\n&lt;VirtualHost *:80&gt;    ServerName example.com    DocumentRoot /var/www/html    &lt;Directory /var/www/&gt;        Options Indexes FollowSymLinks        AllowOverride All        Require all granted    &lt;/Directory&gt;&lt;/VirtualHost&gt;\n","tags":["php","MySQL","网站搭建"]},{"title":"vscode 配置 clangd 和 clang-format","url":"/2024/10/03/vscode-%E9%85%8D%E7%BD%AE-clangd-%E5%92%8C-clang-format/","content":"clangdclangd 是一个基于 clang 的 C&#x2F;C++ 语言服务器，提供了代码补全、静态分析等功能。相较于 vscode 自带的 C&#x2F;C++ 插件，clangd 不需要配置 c_cpp_properties.json，并且在大型项目中的性能表现更好。\n\n  \n    本文假设已经安装了 vscode 并安装了 C/C++ Extension Pack 插件。\n\n  \n\n安装 &amp; 配置\n使用包管理器安装 clangd：\nsudo apt install clangd# 或者安装指定版本sudo apt install clangd-19\n安装完成后，确保 clangd 可执行文件在系统的 PATH 中，可以通过以下命令检查：\nclangd --version\n搜索 vscode 插件 clangd，在 vscode 中搜索 clangd 并安装;\n\n  \n    安装 clangd 插件时，会询问是否安装 clangd，可以比较一下包管理器安装的版本和插件安装的版本，选择较新的版本安装。 \n\n  \n禁用 vscode 自带的 C&#x2F;C++ 插件，避免冲突;\n\n勾选 cmake tools 插件设置中 Export Compile Commands 选项，以生成 compile_commands.json 文件;\n\n在 clangd 插件设置中 Arguments 选项中添加 --compile-commands-dir=$&#123;workspaceFolder&#125;/build，指定 compile_commands.json 文件所在目录;\n\n  \n    clangd 插件会寻找系统中的 clangd 可执行文件，如果使用包管理器安装了指定版本的 clangd，需要在 clangd 插件设置中 Path 选项中指定带版本号的 clangd 可执行文件（如 clangd-19），或者创建一个符号链接 clangd 指向指定版本的 clangd 可执行文件。\n\n  \n\nclangd 的配置文件为 .clangd，可以参考 官方文档 进行配置，也可以不配置，使用默认配置即可。\n使用打开一个 C&#x2F;C++ 项目，clangd 会自动读取 compile_commands.json 文件并进行代码补全和静态分析，若没有生成 compile_commands.json 文件，使用 cmake 生成即可。\n\n  \n    截至文档发布，clangd 仍不支持解析 doxygen 格式的注释。\n\n  \n\nclang-formatclang-format 是一个代码格式化工具，可以根据预定义的风格对 C&#x2F;C++ 代码进行格式化。clang-format 支持多种风格，包括 LLVM、Google、Chromium、Mozilla 和 WebKit，也可以自定义风格。\n安装 &amp; 配置clang-format 的安装方式与 clangd 类似，直接通过包管理安装即可，vscode 安装 clang-format 插件后会自动检测系统中的 clang-format 可执行文件。\nclang-format 的配置文件为 .clang-format，可以参考 官方文档 进行配置。如果项目中没有 .clang-format 文件，会尝试使用用户目录下的 .clang-format 文件。\n下面是笔者使用的 .clang-format 配置文件，注释是 ai 补的，可能需要中译中：\nAccessModifierOffset: -4  # 访问修饰符的偏移量，即子类的访问修饰符相对于父类的偏移量AlignAfterOpenBracket: Align # 在左括号后对齐，即若左括号后有多行参数，参数对齐在左括号后AlignConsecutiveAssignments: false  # 连续赋值对齐，当有多个连续赋值时，是否对齐AlignConsecutiveDeclarations: false # 连续声明对齐，当有多个连续声明时，是否对齐AlignEscapedNewlines: Left  # 转义换行符(\\)对齐AlignOperands: true # 操作数对齐AlignTrailingComments: false  # 尾注释对齐AllowAllParametersOfDeclarationOnNextLine: false  # 允许在下一行声明所有参数AllowShortBlocksOnASingleLine: false  # 允许单行短块AllowShortCaseLabelsOnASingleLine: false  # 允许单行短 case 标签AllowShortFunctionsOnASingleLine: None # 允许单行短函数AllowShortIfStatementsOnASingleLine: false # 允许单行短 if 语句AllowShortLoopsOnASingleLine: false # 允许单行短循环AlwaysBreakAfterDefinitionReturnType: None # 总是在定义后换行返回类型AlwaysBreakAfterReturnType: None # 总是在返回类型后换行AlwaysBreakBeforeMultilineStrings: false # 总是在多行字符串前换行AlwaysBreakTemplateDeclarations: false # 总是在模板声明前换行BinPackArguments: true  # 参数打包BinPackParameters: true # 参数打包BraceWrapping:  # 大括号包装  AfterClass: false             # 类后  AfterControlStatement: false  # 控制语句后  AfterEnum: false              # 枚举后  AfterFunction: true           # 函数后  AfterNamespace: true          # 命名空间后  AfterObjCDeclaration: false   # ObjC 声明后  AfterStruct: false            # 结构体后  AfterUnion: false             # 联合体后    AfterExternBlock: false       # 外部块后  BeforeCatch: false            # catch 前  BeforeElse: false             # else 前  IndentBraces: false           # 缩进大括号  SplitEmptyFunction: true      # 分割空函数  SplitEmptyRecord: true        # 分割空记录  SplitEmptyNamespace: true     # 分割空命名空间BreakBeforeBinaryOperators: None  # 二元操作符前换行BreakBeforeBraces: Custom # 大括号前换行BreakBeforeInheritanceComma: false  # 继承逗号前换行BreakBeforeTernaryOperators: false  # 三元操作符前换行BreakConstructorInitializersBeforeComma: false  # 构造函数初始化器逗号前换行BreakConstructorInitializers: BeforeComma # 构造函数初始化器前换行BreakAfterJavaFieldAnnotations: false # Java 字段注解后换行BreakStringLiterals: false  # 字符串字面量换行CompactNamespaces: false  # 紧凑命名空间ConstructorInitializerAllOnOneLineOrOnePerLine: false # 构造函数初始化器全部在一行或每行一个ConstructorInitializerIndentWidth: 4  # 构造函数初始化器缩进宽度ContinuationIndentWidth: 4  # 续行缩进宽度Cpp11BracedListStyle: false # C++11 大括号列表样式DerivePointerAlignment: false # 指针对齐ExperimentalAutoDetectBinPacking: false # 实验性自动检测打包FixNamespaceComments: false # 修复命名空间注释IncludeBlocks: Preserve # 包含块IncludeCategories:  # 包含类别  - Regex: &#x27;.*&#x27; # 正则表达式    Priority: 1 # 优先级IndentCaseLabels: false # 缩进 case 标签IndentGotoLabels: false # 缩进 goto 标签IndentPPDirectives: None  # 缩进预处理指令IndentWidth: 4  # 缩进宽度IndentWrappedFunctionNames: false # 缩进包装函数名JavaScriptQuotes: Leave # JavaScript 引号JavaScriptWrapImports: true # JavaScript 包装导入KeepEmptyLinesAtTheStartOfBlocks: false # 保留块开头的空行MacroBlockBegin: &#x27;&#x27; # 宏块开始MacroBlockEnd: &#x27;&#x27; # 宏块结束MaxEmptyLinesToKeep: 1  # 保留的最大空行数NamespaceIndentation: None  # 命名空间缩进ObjCBinPackProtocolList: Auto # ObjC 打包协议列表ObjCBlockIndentWidth: 4 # ObjC 块缩进宽度ObjCSpaceAfterProperty: true  # ObjC 属性后空格ObjCSpaceBeforeProtocolList: true # ObjC 协议列表前空格# Taken from git&#x27;s rulesPenaltyBreakAssignment: 10  # 换行赋值PenaltyBreakBeforeFirstCallParameter: 30  # 第一个调用参数前换行PenaltyBreakComment: 10 # 换行注释PenaltyBreakFirstLessLess: 0  # 第一个左移换行PenaltyBreakString: 10  # 换行字符串PenaltyExcessCharacter: 100 # 多余字符PenaltyReturnTypeOnItsOwnLine: 100 # 返回类型在自己的行上PointerAlignment: Right # 指针对齐ReflowComments: true # 重新流动注释SortIncludes: false # 排序 include 文件SortUsingDeclarations: false  # 排序使用声明SpaceAfterCStyleCast: false # C 风格转换后空格SpaceAfterTemplateKeyword: true # 模板关键字后空格SpaceBeforeAssignmentOperators: true  # 赋值操作符前空格SpaceBeforeCtorInitializerColon: true # 构造函数初始化器冒号前空格SpaceBeforeInheritanceColon: true  # 继承冒号前空格SpaceBeforeParens: ControlStatementsExceptForEachMacros   # 括号前空格SpaceBeforeRangeBasedForLoopColon: true # 基于范围的 for 循环冒号前空格SpaceInEmptyParentheses: false  # 空括号中空格SpacesBeforeTrailingComments: 1 # 尾注释前空格SpacesInAngles: false # 尖括号中空格SpacesInContainerLiterals: false  # 容器文字中空格SpacesInCStyleCastParentheses: false  # C 风格转换括号中空格SpacesInParentheses: false  # 括号中空格SpacesInSquareBrackets: false # 方括号中空格TabWidth: 4 # 制表符宽度UseTab: false # 使用制表符","tags":["vscode","clangd","clang-format"]},{"title":"一级倒立摆模型建模","url":"/2025/01/23/%E4%B8%80%E7%BA%A7%E5%80%92%E7%AB%8B%E6%91%86%E6%A8%A1%E5%9E%8B%E5%BB%BA%E6%A8%A1/","content":"\n如图所示一级倒立摆模型，质量块  位于杆  末端，底部滑块质量为 , 摩擦系数为 。设杆与竖直方向夹角为 ，底部滑块位移为 ，滑块所受外力为 。\n符号及含义如下表所示\n\n\n\n符号\n含义\n\n\n\n\n质量块质量\n\n\n\n底部滑块质量\n\n\n\n杆长\n\n\n\n摩擦系数\n\n\n\n重力加速度\n\n\n\n底部滑块所受外力\n\n\n\n质量块在水平方向的受力\n\n\n\n质量块在竖直方向的受力\n\n\n\n质量块转动惯量\n\n\n\n杆与竖直方向夹角\n\n\n\n底部滑块位移\n\n\n运动方程对于质量块 ，有：\n\n其中  为质量块在水平方向的受力， 为质量块在竖直方向的受力， 为转动惯量。结果如下：\n\n将  和  代入第三个方程，得到：\n\n当  很小时，有 ，则：\n\n整理得到：\n\n对于底部滑块，有：\n\n将  代入，整理得到：\n\n同样，当  很小时，有 ，则：\n\n 和  为一级倒立摆模型的运动方程。\n状态空间方程分别将  代入  和  代入 ，得到：\n\n定义状态变量 ，则有：\n\n 即为一级倒立摆模型的状态空间方程。\n根据状态空间方程得到矩阵形式：\n\n","tags":["RoboMaster","轮腿","控制"]},{"title":"五连杆正运动学解算","url":"/2025/01/23/%E4%BA%94%E8%BF%9E%E6%9D%86%E6%AD%A3%E8%BF%90%E5%8A%A8%E5%AD%A6%E8%A7%A3%E7%AE%97/","content":"\n正运动学解算如图所示五连杆模型，其中 、 为关节电机；、 为电机输出角度，可由编码器读出； 为连杆长度。需要求解  和 。\n以  中点  为原点， 为  轴，垂直  的向上为  轴，建立平面直角坐标系。设  的坐标分别为 。\n对于  点，有：\n\n对公式  移项并平方相加，得：\n\n令 ，则有：\n\n移项，令 ，则有：\n\n由二倍角公式，有：\n\n则  式可化为：\n\n整理得：\n\n 式为关于  的一元二次方程，其判别式：\n\n其解为：\n\n则有：\n\n考虑机械结构及限位，，当  时，判别式  恒成立：\n\n易知  式的解其实就是  和 。根据图中关系有：\n\n因此取正根：\n\n由此可求出  点坐标 ：\n\n化为极坐标系，解出  和 ：\n\n至此，五连杆正运动学解算完毕。\n计算力矩转换的雅可比矩阵上面由正运动学解算将五连杆机构构造成了一个虚拟的倒立摆模型。虽然可以简化我们的控制算法，但在实际控制中，仍然需要将电机的力矩转换为虚拟倒立摆的力矩。我们可以通过雅可比矩阵来实现这个转换。\n\n本部分参考玺佬的文章，这里只贴 matlab 代码，具体推导过程请参考原文。\n\nsyms x_A x_E y_A y_E phi_1(t) phi_2(t) phi_3(t) phi_4(t) phi_dot_1 phi_dot_4 l_1 l_2 l_3 l_4 l_5% 位置关系x_A = -l_5/2;x_E = l_5/2;y_A = 0;y_E = 0;x_B = x_A + l_1*cos(phi_1);y_B = y_A + l_1*sin(phi_1);x_D = x_E + l_4*cos(phi_4);y_D = y_E + l_4*sin(phi_4);x_C = x_B + l_2*cos(phi_2);y_C = y_B + l_2*sin(phi_2);% 速度关系x_dot_B = diff(x_B,t);y_dot_B = diff(y_B,t);x_dot_D = diff(x_D,t);y_dot_D = diff(y_D,t);x_dot_C = diff(x_C,t);y_dot_C = diff(y_C,t);phi_dot_2 = ((x_dot_D-x_dot_B)*cos(phi_3)+(y_dot_D-y_dot_B)*sin(phi_3))/l_2/sin(phi_3-phi_2);% 代数x_dot_C = subs(x_dot_C,diff(phi_2,t),phi_dot_2);x_dot_C = subs(x_dot_C,[diff(phi_1,t),diff(phi_4,t)],[phi_dot_1,phi_dot_4]);y_dot_C = subs(y_dot_C,diff(phi_2,t),phi_dot_2);y_dot_C = subs(y_dot_C,[diff(phi_2,t),diff(phi_1,t),diff(phi_4,t)],[phi_dot_2,phi_dot_1,phi_dot_4]);% 计算雅可比矩阵x_dot = [x_dot_C;y_dot_C];q_dot = [phi_dot_1;phi_dot_4];x_dot = simplify(collect(x_dot,q_dot));J=simplify(jacobian(x_dot,q_dot))% 转极坐标syms phi_0 l_0R = [cos(phi_0-pi/2) -sin(phi_0-pi/2);     sin(phi_0-pi/2)  cos(phi_0-pi/2)];M = [0 -1/l_0;     1     0];T = simplify(J.'*R*M)\n\n最后得出的结果与原文一致：\n\n","tags":["RoboMaster","轮腿","控制"]},{"title":"交叉编译 OpenCV 踩坑记录","url":"/2024/10/24/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91-OpenCV-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","content":"最近准备一个比赛，用到了香橙派，需要在上面跑 OpenCV，并且需要高版本，只能编译安装。由于香橙派的性能有限，所以选择在自己电脑上交叉编译，然后把编译好的库拷贝到香橙派上。\n\nOS: Ubuntu 24.04OpenCV: 4.10.0toolchain: aaarch64-linux-gnutarget: OrangePi Zero3\n\n配置交叉编译工具链直接使用 apt 安装：\nsudo apt install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu\n\n从 github 上克隆 OpenCV 源码：\ngit clone https://github.com/opencv/opencv.gitgit clone https://github.com/opencv/opencv_contrib.gitcd opencv\n\n创建一个 build 目录，进入 build 目录：\nmkdir build &amp;&amp; cd build\n\n打开 cmake-gui，配置交叉编译：\ncmake-gui ..\n\n点击 Configure，选择 Unix Makefiles 和 Specify toolchain file for cross-compiling，然后 Next，如图：\n\n第二页是编译选项。Target System 选择 Linux；Compiler 下 C 和 C++ 中分别填入 aarch64-linux-gnu-gcc 和 aarch64-linux-gnu-g++ 的路径；Find Program/Library/Include 下，Target Root 填入交叉编译工具链的路径 /usr/aarch64-linux-gnu，其他按图中篇配置：\n\n解释一下 Find Program/Library/Include 中的配置：\n\nTarget Root：交叉编译工具链的路径，这个路径下应该有 bin、lib、include 等目录\n其他三个选项: Search in Target Root，表示在 Target Root 下搜索，Search in native system 表示在本地系统搜索\n\n这里由于需要移植到一个新环境，所以选择了 Search in Target Root。\n配置完成点击 Finish。\n配置 OpenCV上面步骤完成后，不要直接点击 Generate，还需要配置一些选项。\n配置 OpenCV_contrib搜索 OPENCV_EXTRA_MODULES_PATH，填入 opencv_contrib 的路径：\n\n由于我是在 opencv 目录下创建的 build 目录，之前我们在上级目录中克隆的 opencv 和 opencv_contrib，所以这里填入 ../opencv_contrib/modules。\n关闭 dnn 模块由于 dnn 模块在编译 arm 版本时会出现问题, 所以需要关闭 dnn 模块。当然可以先尝试编译，如果编译失败，再关闭。\n\n  \n    2025-04-04 更新: 该 issue 已经关闭，根据最后一条回复该问题已经修复，但笔者并未尝试过。\n\n  \n\n搜索 BUILD_opencv_dnn，将其设置为 OFF：\n\n配置完成后，点击 Generate。\n交叉编译 OpenCV命令行编译：\nmake -j$(nproc --ignore=2) # 留两个线程给系统\n然后等待报错。\nlibpng 报错表现为找不到一些定义：\n../../lib/libopencv_imgcodecs.so.4.10.0: undefined reference to &#x27;png_do_expand_palette_rgb8_neon&#x27;../../lib/libopencv_imgcodecs.so.4.10.0: undefined reference to &#x27;png_init_filter_functions_neon&#x27;../../lib/libopencv_imgcodecs.so.4.10.0: undefined reference to &#x27;png_do_expand_palette_rgba8_neon&#x27;../../lib/libopencv_imgcodecs.so.4.10.0: undefined reference to &#x27;png_riffle_palette_neon&#x27;\n\n解决方法\n修改 OpenCV 根目录下 3rdparty/libpng/pngpriv.h 文件，将\n# if (defined(ARM_NEON) || defined(__ARM_NEON)) &amp;&amp; */\n\n修改为\n# if defined(PNG_ARM_NEON) &amp;&amp; (defined(ARM_NEON) || defined(__ARM_NEON)) &amp;&amp; \\\n\n然后重新编译。\ndnn 报错上面已经给出了解决方法，关闭 dnn 模块。\n安装 OpenCV编译完成后，安装：\nmake install\n\n会在 build 目录下生成 install 目录，里面包含了编译好的库。\ninstall # 目录结构├── bin # 可执行文件├── include # 头文件├── lib # 库文件└── share # 其他文件\n\n将 install 目录拷贝到目标设备上，这里我直接拷贝到项目目录下的 3rd-party 目录，然后配置 CMakeLists.txt：\nset(OPENCV_DIR $&#123;CMAKE_SOURCE_DIR&#125;/3rd-party/opencv)find_package(OpenCV REQUIREDPATHS $&#123;OPENCV_DIR&#125;NO_DEFAULT_PATH)\n\n这样就可以在项目中使用交叉编译好的 OpenCV 了。\n处理编译运行项目代码时报错运行项目代码时可能会报错，比如：\nerror while loading shared libraries: libopencv_imgcodecs.so.410: cannot open shared object file: No such file or directory\n\n通过 ldd 命令发现：\nldd main# 输出# ...        libopencv_imgcodecs.so.410 =&gt; not found        libopencv_video.so.410 =&gt; not found        libopencv_calib3d.so.410 =&gt; not found        libopencv_features2d.so.410 =&gt; not found        libopencv_flann.so.410 =&gt; not found# ...\n\n这是由于系统找不到这些库，需要配置动态链接库路径。在 etc/ld.so.conf 中添加库路径：\nsudo vim /etc/ld.so.conf\n\n在文件中添加：\n/path/to/opencv/install/lib\n\n然后运行：\nsudo ldconfig\n\n再次运行项目代码，应该就不会报错了。\n","tags":["cmake","OpenCV"]},{"title":"传统视觉理论及实践","url":"/2024/04/26/%E4%BC%A0%E7%BB%9F%E8%A7%86%E8%A7%89%E7%90%86%E8%AE%BA%E5%8F%8A%E5%AE%9E%E8%B7%B5/","content":"什么是计算机视觉计算机视觉（Computer Vision）是一门研究如何使机器“看”的科学，它利用摄像头和计算机算法，让机器能够像人一样“看”，并且能够从中获取信息。计算机视觉是一门多领域交叉的学科，涉及到计算机科学、数学、物理学、生物学、心理学等多个学科。\n\n\n计算机视觉的研究对象是图像，目的是从图像中获取信息。\n\nQ: 从图像中能获取什么信息？A: 物体的位置、大小、形状、颜色、纹理、运动等。\n\n图像图像的类型\n\n\n\n\n\n\n\n\n彩色图像\n多光谱图像\n纹理图像\n\n\n立体图像\n深度图像\n3D图像\n\n\n序列图像\n投影重建图像\n合成图像\n\n\n图像的存储方式图像由像素组成，像素是组成图像的最小单元，每个像素可以看做一个多维向量。\n\n例如，一幅  的灰度图像可以看做一个  的矩阵，其中每个元素表示一个像素的灰度值；一幅  的彩色图像可以看做一个  的张量，其中每个元素表示一个像素的 RGB 三个通道的值。\n我们可以把彩色图像看做是三个灰度图像的叠加，每个灰度图像对应一个通道，一般是红、绿、蓝三个通道。\n\nQ: 为什么是红、绿、蓝三个通道？A: 人眼就是由红、绿、蓝三种颜色的感光细胞感觉光线的。\n\n例：分离 RGB 通道（opencv, cpp）。\n#include &lt;opencv2/opencv.hpp&gt;#include &lt;vector&gt;int main(int argc, char* argv[]){    cv::Mat src = cv::imread(argv[1]);  // 读取图像    std::vector&lt;cv::Mat&gt; dst;   // 存储分离后的通道    cv::split(src, dst);    // 分离通道    cv::namedWindow(\"src\", cv::WINDOW_NORMAL);  // 创建窗口，WINDOW_NORMAL 表示窗口大小可以调整    cv::namedWindow(\"B\", cv::WINDOW_NORMAL);    cv::namedWindow(\"G\", cv::WINDOW_NORMAL);    cv::namedWindow(\"R\", cv::WINDOW_NORMAL);    cv::imshow(\"src\", src); // 显示图像    cv::imshow(\"B\", dst[0]);    cv::imshow(\"G\", dst[1]);    cv::imshow(\"R\", dst[2]);        cv::waitKey(0); // 等待窗口关闭 (0表示一直等待)    return 0;}\n\n\n色彩空间上面提到了 RGB 色彩空间，除了 RGB 色彩空间，还有很多其他的色彩空间，例如 CMY、HSI、HSV 等。不同的色彩空间有不同的特点，适用于不同的场景。\n\n例：RGB 转 HSV 并分离三通道。\n#include &lt;opencv2/opencv.hpp&gt;#include &lt;vector&gt;int main(int argc, char* argv[]){    cv::Mat src = cv::imread(argv[1]);  // 读取图像    cv::Mat hsv;    // 存储 HSV 图像    std::vector&lt;cv::Mat&gt; dst;   // 存储分离后的通道    cv::cvtColor(src, hsv, cv::COLOR_BGR2HSV);    // RGB 转 HSV    cv::split(hsv, dst);    // 分离通道    cv::namedWindow(\"src\", cv::WINDOW_NORMAL);  // 创建窗口，WINDOW_NORMAL 表示窗口大小可以调整    cv::namedWindow(\"H\", cv::WINDOW_NORMAL);    cv::namedWindow(\"S\", cv::WINDOW_NORMAL);    cv::namedWindow(\"V\", cv::WINDOW_NORMAL);    cv::imshow(\"src\", src); // 显示图像    cv::imshow(\"H\", dst[0]);    cv::imshow(\"S\", dst[1]);    cv::imshow(\"V\", dst[2]);        cv::waitKey(0); // 等待窗口关闭 (0表示一直等待)    return 0;}\n\n\n\nQ: HSV 相较于 RGB 有什么优势？A: HSV 色彩空间更符合人类视觉感知，更容易区分颜色。\n\n补充：像素的基本操作邻域\n\n四邻域：上下左右四个像素\n对角邻域：左上、右上、左下、右下四个像素\n八邻域：四邻域 + 对角邻域\n\n\n像素的距离\n\n欧式距离：\n曼哈顿距离：\n切比雪夫距离(棋盘距离)：\n\n\n滤波图像滤波是图像处理中的一种基本操作，它可以使图像变得更加平滑，去除噪声，增强图像的细节等。\n卷积卷积是图像滤波的基础，它是一种数学运算，用于图像处理中的滤波操作。\n其数学表达式为：\n\n其中， 是原始图像， 是卷积核， 是卷积后的图像， 是卷积核的半径， 是图像坐标， 是卷积核坐标。\n例如，下面是一个  的卷积核：\n\n例：使用卷积处理图像。\n#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char* argv[]) {    cv::Mat src = cv::imread(argv[1]);    cv::Mat dst;    cv::Mat kernel; // 卷积核    kernel = (cv::Mat_&lt;float&gt;(3, 3) &lt;&lt; 0, -1, 0, -1, 4, -1, 0, -1, 0);  // 创建卷积核    cv::filter2D(src, dst, -1, kernel); // 卷积        cv::namedWindow(\"src\", cv::WINDOW_NORMAL);    cv::namedWindow(\"dst\", cv::WINDOW_NORMAL);    cv::imshow(\"src\", src);    cv::imshow(\"dst\", dst);        cv::waitKey(0);    return 0;}\n\n\n常见滤波器均值滤波\n均值滤波是一种最简单的滤波器，它将每个像素的值替换为其邻域像素的平均值。\n\n中值滤波\n中值滤波是一种非线性滤波器，它将每个像素的值替换为其邻域像素的中值。\n高斯滤波\n高斯滤波是一种线性滤波器，它将每个像素的值替换为其邻域像素的加权平均值。\n先按照公式计算权重，然后归一化到和为1。\n\n\n如：\n锐化滤波\n锐化滤波是一种增强图像细节的滤波器，它强调与局部平均之间的差异。\n\n\n\n当然，卷积核不一定是  的，也可以是其他尺寸的。如下图所示，是一个  的高斯卷积核：\n\n补充：频域傅里叶变换是一种信号处理中常用的方法，它可以将信号从时域转换到频域，从而更好地理解信号的特征。\n\n将图像看做是一个二维信号，我们可以对图像进行傅里叶变换，得到图像的频谱：\n\n例如：\n\nFFT的结果是复数形式，保留了图像的全部信息，但去绝对值得到的频谱图只表现了振幅而没有体现相位。\n在频域中，我们可以对图像进行滤波，然后再进行逆变换，得到滤波后的图像。\n例：使用 DFT 进行频域低通滤波。\n#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char* argv[]) {    cv::Mat src = cv::imread(argv[1]);    cv::Mat dst;    cv::Mat padded; // 填充后的图像    cv::Mat complexI; // 复数形式的频谱图    cv::cvtColor(src, src, cv::COLOR_BGR2GRAY); // 转换为灰度图    src.convertTo(padded, CV_32F); // 转换为浮点型    int m = cv::getOptimalDFTSize(padded.rows);    int n = cv::getOptimalDFTSize(padded.cols);    cv::copyMakeBorder(padded, padded, 0, m - padded.rows, 0, n - padded.cols, cv::BORDER_CONSTANT, cv::Scalar::all(0)); // 填充图像    cv::dft(padded, complexI, cv::DFT_COMPLEX_OUTPUT); // 傅里叶变换    // 分成四个象限    cv::Mat q0 = complexI(cv::Rect(0, 0, complexI.cols / 2, complexI.rows / 2));    cv::Mat q1 = complexI(cv::Rect(complexI.cols / 2, 0, complexI.cols / 2, complexI.rows / 2));    cv::Mat q2 = complexI(cv::Rect(0, complexI.rows / 2, complexI.cols / 2, complexI.rows / 2));    cv::Mat q3 = complexI(cv::Rect(complexI.cols / 2, complexI.rows / 2, complexI.cols / 2, complexI.rows / 2));    // 交换象限    cv::Mat tmp;    q0.copyTo(tmp);    q3.copyTo(q0);    tmp.copyTo(q3);    q1.copyTo(tmp);    q2.copyTo(q1);    tmp.copyTo(q2);        // 生成低通滤波器    int radius = 100;    cv::Mat lowPass = cv::Mat::zeros(complexI.size(), CV_32FC2);    cv::Point center = cv::Point(lowPass.cols / 2, lowPass.rows / 2);    cv::circle(lowPass, center, radius, cv::Scalar(1), -1);    // 滤波    cv::mulSpectrums(complexI, lowPass, complexI, 0);    cv::namedWindow(\"complexI\", cv::WINDOW_NORMAL);    cv::Mat plane[] = { cv::Mat::zeros(complexI.size(), CV_32F),                        cv::Mat::zeros(complexI.size(), CV_32F) };    cv::split(complexI, plane);    cv::magnitude(plane[0], plane[1], plane[0]);    // 求幅值    cv::log(plane[0] + cv::Scalar::all(1), plane[0]);   // 对数变换，方便显示    cv::normalize(plane[0], plane[0], 0, 1, cv::NORM_MINMAX);   // 归一化    cv::imshow(\"complexI\", plane[0]);   // 显示频谱图    // 交换象限    q0.copyTo(tmp);    q3.copyTo(q0);    tmp.copyTo(q3);    q1.copyTo(tmp);    q2.copyTo(q1);    tmp.copyTo(q2);    cv::idft(complexI, dst, cv::DFT_SCALE | cv::DFT_REAL_OUTPUT); // 傅里叶逆变换    cv::normalize(dst, dst, 0, 255, cv::NORM_MINMAX); // 归一化    dst.convertTo(dst, CV_8UC1); // 转换为8位图    cv::namedWindow(\"src\", cv::WINDOW_NORMAL);    cv::namedWindow(\"dst\", cv::WINDOW_NORMAL);    cv::imshow(\"src\", src);    cv::imshow(\"dst\", dst);    cv::waitKey(0);    return 0;}\n\n\n\nQ: 高通滤波？A: 高通滤波后，图像的低频部分会被去除，只保留高频部分，使图像的边界更突出。\n\n边缘检测边缘检测是图像处理中的一种基本操作，它可以检测图像中的边缘，从而提取出图像的轮廓。\n\n卷积微分图像中的边缘可以看做是图像灰度的突变，因此我们可以通过对图像进行微分来检测边缘。\n下面给出二维图像的偏导：\n\n\n上述公式推导过程简单，这里不再赘述。由此，我们可以得到一维卷积核：\n\n\n直接对图像求导会受到噪声的干扰，因此一般需要对图像先做一次平滑，减少噪声的干扰，再做求导。\nSobel 算子Sobel 算子是一种常用的边缘检测算子，它是一种线性滤波器，可以检测图像中的水平和垂直边缘。\n\n\n例：使用 Sobel 算子进行边缘检测。\n#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char* argv[]) {    cv::Mat src = cv::imread(argv[1]);    cv::Mat dst;    cv::Mat gray;    cv::Mat grad_x, grad_y;    cv::Mat abs_grad_x, abs_grad_y;    cv::cvtColor(src, gray, cv::COLOR_BGR2GRAY); // 转换为灰度图    cv::Sobel(gray, grad_x, CV_16S, 1, 0, 3); // x 方向梯度    cv::Sobel(gray, grad_y, CV_16S, 0, 1, 3); // y 方向梯度    cv::convertScaleAbs(grad_x, abs_grad_x); // 转换为8位图    cv::convertScaleAbs(grad_y, abs_grad_y); // 转换为8位图    cv::addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, dst); // 合并梯度    cv::namedWindow(\"src\", cv::WINDOW_NORMAL);    cv::namedWindow(\"dst\", cv::WINDOW_NORMAL);    cv::imshow(\"src\", src);    cv::imshow(\"dst\", dst);    cv::waitKey(0);    return 0;}\n\n\nsobel 算子是一种有限差分算子，相同的有限差分算子还有 Prewitt、Roberts、Scharr 等。\nPrewitt\n\n\nRoberts\n\n\nScharr\n\n\n不仅有水平和垂直方向的，还有对角方向的。\n拉普拉斯算子拉普拉斯算子是一种二阶微分算子，可以检测图像中的边缘。\n其数学表达式为：\n\n由上式我们可以得到拉普拉斯算子的卷积核：\n\n\nDoG &amp; LoGDoG（Difference of Gaussian）是高斯滤波的差分，指的是先对图像进行两次高斯滤波，然后再求差分。\n\nLoG（Laplacian of Gaussian）是高斯滤波的拉普拉斯，指的是先对图像进行高斯滤波，然后再求拉普拉斯。\n\n卷积的微分定理\n\nCanny 边缘检测Canny 边缘检测是一种多步骤的边缘检测算法，它包括以下几个步骤：\n\n高斯滤波：减少噪声\n梯度计算：计算图像的梯度\n非极大值抑制：抑制非边缘像素\n迟滞阈值化：确定边缘\n\n例：用 Canny 算子进行边缘检测。\n#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char* argv[]) {    cv::Mat src = cv::imread(argv[1]);    cv::Mat dst;    cv::Mat gray;    cv::cvtColor(src, gray, cv::COLOR_BGR2GRAY); // 转换为灰度图    cv::Canny(gray, dst, 50, 150); // Canny 边缘检测    cv::namedWindow(\"src\", cv::WINDOW_NORMAL);    cv::namedWindow(\"dst\", cv::WINDOW_NORMAL);    cv::imshow(\"src\", src);    cv::imshow(\"dst\", dst);    cv::waitKey(0);    return 0;}\n\n\n角点检测角点是图像中的一种特殊的特征点，它是图像中的局部最大值，可以用来进行图像配准、目标跟踪等。\n\n\nHarris 角点检测Harris 角点检测是一种常用的角点检测算法，它是一种基于图像灰度的角点检测算法。\n其表达矩阵可借助图像中的局部模板里两个方向梯度来定义，一种常见的表达矩阵为：\n\n其中， 是图像的梯度， 是窗口函数，通常是高斯函数。\n将矩阵  分解为特征值和特征向量，得到两个特征值 ，改写为：\n\n则角点响应函数为：\n\n其中， 是矩阵  的行列式， 是矩阵  的迹， 是一个常数。\nHarris 角点检测算法的步骤如下：\n\n计算图像的局部梯度\n局部图像梯度减去均值\n计算协方差矩阵\n计算特征值和特征向量\n利用阈值筛选角点\n\n例：使用 Harris 角点检测算法检测角点。\n#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char* argv[]) {    cv::Mat src = cv::imread(argv[1]);    cv::Mat dst;    cv::Mat gray;    cv::Mat dst_norm, dst_norm_scaled;    cv::cvtColor(src, gray, cv::COLOR_BGR2GRAY); // 转换为灰度图    cv::cornerHarris(gray, dst, 2, 3, 0.04); // Harris 角点检测    cv::normalize(dst, dst_norm, 0, 255, cv::NORM_MINMAX, CV_32FC1, cv::Mat()); // 归一化    cv::convertScaleAbs(dst_norm, dst_norm_scaled); // 转换为8位图    for (int i = 0; i &lt; dst_norm.rows; i++) {        for (int j = 0; j &lt; dst_norm.cols; j++) {            if ((int)dst_norm.at&lt;float&gt;(i, j) &gt; 100) {                cv::circle(src, cv::Point(j, i), 5, cv::Scalar(0, 0, 255), 2, 8, 0);            }        }    }    cv::namedWindow(\"src\", cv::WINDOW_NORMAL);    cv::imshow(\"src\", src);    cv::waitKey(0);    return 0;}\n\n形态学主要用于图像的形状分析、特征提取等。\n膨胀与腐蚀膨胀与腐蚀是形态学中的两种基本操作，它们可以用于图像的去噪、分割等。\n膨胀\n可以使图像中的物体变大，或者连接两个物体。\n\n其中， 是原始图像， 是结构元素， 是膨胀操作。\n\n腐蚀\n可以使图像中的物体变小，或者分割两个物体。\n\n其中， 是原始图像， 是结构元素， 是腐蚀操作。\n\n开运算与闭运算开运算\n先腐蚀后膨胀，可以去除小的噪声。\n\n\n闭运算\n先膨胀后腐蚀，可以填充小的空洞。\n\n\n例：使用形态学操作进行图像处理。\n#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char* argv[]) {    cv::Mat src = cv::imread(argv[1]);    cv::Mat dst;    cv::Mat gray;    cv::Mat element = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5)); // 结构元素    cv::cvtColor(src, gray, cv::COLOR_BGR2GRAY); // 转换为灰度图    cv::threshold(gray, gray, 100, 255, cv::THRESH_BINARY); // 二值化        cv::namedWindow(\"src\", cv::WINDOW_NORMAL);    cv::namedWindow(\"dilate\", cv::WINDOW_NORMAL);    cv::namedWindow(\"erode\", cv::WINDOW_NORMAL);    cv::namedWindow(\"close\", cv::WINDOW_NORMAL);    cv::namedWindow(\"open\", cv::WINDOW_NORMAL);    cv::imshow(\"src\", src);        cv::morphologyEx(gray, dst, cv::MORPH_DILATE, element); // 膨胀    cv::imshow(\"dilate\", dst);    cv::morphologyEx(gray, dst, cv::MORPH_ERODE, element); // 腐蚀    cv::imshow(\"erode\", dst);    cv::morphologyEx(gray, dst, cv::MORPH_CLOSE, element); // 闭运算    cv::imshow(\"close\", dst);    cv::morphologyEx(gray, dst, cv::MORPH_OPEN, element); // 开运算    cv::imshow(\"open\", dst);    cv::waitKey(0);    return 0;}\n\n\n","tags":["C/C++","OpenCV","计算机视觉"]},{"title":"你好，2024","url":"/2023/12/31/%E4%BD%A0%E5%A5%BD2024/","content":"我前几天想发布一篇年末总结，但是因为有事（懒），没有写，然后就拖到了这个时候。这个时候发布，就不叫年末总结了，于是想标题想了很久，最后选择了这个标题，Neta 一下程序员们写的第一个程序。就内容而言，我还是将它分为两个部分。\n2023 年总结2023 年，过去的两个学期没有挂科、没有奖学金、还活着，这学期大概也是这样了。二战六级，分数还不知道（我猜能过）。在杭电的生活是自由的，你想卷可以卷，学校有一定的资源；不想卷可以不卷，也还过得去。显然我是后者（笑）。\n2023 年，玩游戏的时间大大减少，因为真的没时间玩了。但是也挤出了时间推完了樱之诗（樱之刻汉化什么时候出, FUTA自什么时候爆樱之响）、Eden*，前几天开始推 ATRI 的精神续作 GINKA，还在推，剧情非常熟悉。年末几个月开始玩文明6和怪猎 什么时候能遇到一个像美咕噜一样的学妹，将一天游戏时间控制到了 25 小时之内。舰C半弃坑，肝不动了，肝小碧蓝去了（凹总力战凹的）。\n2023 年对我而言是一个非常难忘的一年，其中最重要的一点是我成为了一名 RMer，这是我非常荣幸的一件事，也是我认为做过的最正确的决定。虽然它占用了我大量的时间，但我认为这是值得的。\n虽然打 RM 会变得非常不幸\n\n在这里我认识了很多优秀的人，也学到了很多东西。在所谓“校园与社会脱节”的现状下，Robomaster 给我一个很好的机会去接触较为真实的开发场景。它不再是学校里的一门课，而是一个真正的项目，有着真正的目标，有着真正的团队，有着真正的开发流程。过程不再是理想化的，而是会遇到非常多的问题。为了解决这些问题可能需要一天甚至一个月的时间，这是真正的开发。我认为这是一个非常好的锻炼机会，也是一个非常好的学习机会。\n我做过哨兵，学习了导航的技术栈；做过自瞄，学习了图形图像处理的技术栈；做过工程的视觉，学习了机械臂的逆运动学解算；此外还学习了非常多的其他知识，这让我见识到了一个合理、高效、优雅的代码是什么样的。在惊叹的同时也让我意识到了自己实力的不足，我还有很多要学习的东西和增进的地方，这让我更加坚定了我要继续学习的决心。\n队友的支持，让我成为了战队视觉组的组长，这对我来说是一个非常大的挑战。我以前没有管理过团队，更没有管理项目开发的经历，一上来就管理近10人的团队多少有些吃力，同时我心里其实是拒绝的：我想做技术工作，而不是管理工作。开始的一段时间我天天给自己做思想工作，让自己能接受做管理工作。于是我留实验室的时间更长了，每天不仅要做技术工作，还要抽空考虑今后团队的发展，跟进每项工作的进度，帮助做技术支持等等。很忙，但很充实，这段时间我觉得我学到了非常多的东西，不仅仅是技术层面，还有团队管理方法，人际交流等。我要特别感谢我的队友们，管理工作我做的不算很好，而且我的性格其实是不适合做管理工作的，说话很直，很多时候会伤到人，但他们对我非常包容，而且能理解我的意思，这让我非常感动，谢谢你们。\n\n年末我给视觉组放了个假，拉了两个人（大怨种）去广州参加萤火虫漫展，爆了点米，还是很开心的。在广州逛了一圈，感觉还是不错的，广州的生活比较悠闲，我比较喜欢。另外我们发现，所谓的“冰室”好像就是珠三角的沙县小吃。\n\n\n这图我们拍的，还意外成为了一次互联网图源（乐）\n\n2024 年展望2024 年，尽量不挂科 :(。\n最重要的是能管理好视觉组，让视觉组“让某位成员女装”的任务能够圆满完成，争取能够在 Robomaster 2024 的比赛中取得好成绩；做好下一届的培养，让他们能够顺利接手视觉组的工作。同时继续学习，提升自己的能力，让在 Robomaster 中学到的东西能够在以后的工作中发挥作用，让这段时间的花费是值得的，这也是我想告诉我的队员们的：不要浪费自己的时间。\n最后，祝看到这篇文章的人新年快乐，2024 年万事如意。\n让我们在新的一年里继续传递友谊与爱的魔法吧！\n\n2024 年 1 月 1 日 00:23:57于广州\n"},{"title":"博客搭建（一）建站","url":"/2023/10/05/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89%E5%BB%BA%E7%AB%99/","content":"简述本博客使用 Hexo 博客框架，主题采用 radefine 搭建，最终发布到 github pages。\n安装 Hexo官方教程\nHexo 是一个基于 Node.js 的静态页面博客框架，安装 Hexo 前需要安装 Node.js 和 git 。笔者之前安装过这两个应用，在这里不详细介绍它们的安装过程。\n安装完上述应用后，打开控制台，输入：\nnpm install -g hexo-cli\n\n即可安装 Hexo 。\n创建博客在打算放置博客的路径下打开控制台，输入：\nhexo init &quot;your-blog-name&quot;cd your-blog-namenpm install\n\n执行完成后，当前文件夹的文件结构如下：\n.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes\n\n_config.yml网站的配置文件。\npackage.json网站所需要的程序包。\nscaffolds模板文件夹，新建文章时会根据该文件夹下的模板创建文件。\nsource资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。\ntheme主题文件夹。\n安装主题新建的 Hexo 博客默认使用 landscape 主题。\n在 这里 可以找到更多的 Hexo 主题，每个主题有不同的配置方法，请根据文档进行配置，此处不做赘述。\n在博客根目录打开控制台，输入：\nhexo server\n\n结果如下：\nINFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.\n\n此时用浏览器访问 http://localhost:4000/ 可预览网页。\n申请github pages官方教程\n创建仓库创建用户或组织站点，则存储库必须命名为 &lt;user&gt;.github.io 或 &lt;organization&gt;.github.io ，全小写。\n创建站点新建站点入口文件。GitHub Pages 将查找 index.html、index.md 或 README.md 文件，作为站点的入口文件。\n\n进入仓库，找到 “settings”，打开。\n在边栏中找到 “pages”，打开。\n选择分支，点击 “save”。\n\n等待一段时间后点击上方 “visit site” 或通过网址访问网页。\n\n  \n    对站点的更改在推送到 GitHub 后，最长可能需要 10 分钟才会发布。\n\n  \n\nHexo 连接到 github pages先安装 hexo-deployer-git 插件，在博客根目录下运行：\nnpm install hexo-deployer-git\n\n在 _config.yml 文件中添加或修改下方内容：\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: &#x27;git&#x27;  repo: &#x27;https://github.com/&lt;user&gt;/&lt;user&gt;.github.io.git&#x27;  branch: &#x27;&lt;your-branch&gt;&#x27;\n\n打开控制台，输入：\nhexo clean # 清空上次生成的文件，第一次运行可不运行hexo generate # 生成上传到仓库的文件，保存在 public 文件夹下hexo deploy # 上传到仓库，第一次运行需要绑定 github 账号\n","tags":["start"]},{"title":"博客搭建（三）配置CDN","url":"/2023/10/06/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%89%EF%BC%89%E9%85%8D%E7%BD%AECDN/","content":"github pages 的服务器在国外，国内访问速度较慢。笔者尝试过免费的 CDN，如 staticfile、cdnjs，但是效果不是很好。之后看到了 cloudflare，有免费的CDN，准备上手尝试。\n\n需要的工具：\n\n一个域名\n一个 github pages 的博客\n一个 cloudflare 的账号\n\n\ncloudflare 的配置注册 cloudflare 账号，添加域名cloudflare 会自动扫描域名的 DNS 记录，添加 A 记录和 CNAME 记录，如果没有，手动添加 \n手动添加 DNS 记录边栏里选择 DNS-&gt;记录-&gt;添加记录A 记录指向 github pages 的服务器 ipv4 地址，地址如下：\n185.199.108.153185.199.109.153185.199.110.153185.199.111.153\n个人博客具体的服务器地址可通过 ping username.github.io 获取CNAME 记录指向 github pages 的域名，即 username.github.io\n更改域名的 DNS 服务器更改域名的 DNS 服务器为 cloudflare 的 DNS 服务器。笔者的域名在阿里云上购买注册，其它域名注册商的操作应该类似。\ngithub pages 的配置在 github pages 的仓库中添加 CNAME 文件，内容为自己的域名，如 www.example.com，然后在仓库的设置中添加自定义域名，如下图：等待出现图上提示的DNS check successful，即可访问自己的域名了。\n\n  \n    若出现 ERROR 提示，检查 cloudflare 是否添加记录，如果已添加可能是 DNS 服务器还没有更新，等待一段时间再试。\n\n  \n\nenforce https在 cloudflare 的 SSL&#x2F;TLS 中设置 Always Use HTTPS 为 On，这样就可以强制使用 https 了。\n","tags":["Cloudflare","start"]},{"title":"博客搭建（二）发表文章","url":"/2023/10/05/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%91%E8%A1%A8%E6%96%87%E7%AB%A0/","content":"新建文章命令\nhexo new [layout] &lt;title&gt;\n\n用于新建文章或者页面，文章的布局（layout）默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。\nHexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。\n新建页面文件格式为 markdown。\n草稿layout 设置为 draft 新建草稿，通过 publish 命令可以把草稿发布 ：\n$ hexo publish [layout] &lt;title&gt;\n\n草稿默认不会显示在页面中，可在执行时加上 --draft 参数，或是在 _config.yml 中把 render_drafts 参数设为 true 来预览草稿。\nredefine 附加语法notesnote large格式：（notel 意思是 note large ，方便记，也可以写成 note-large ）\n&#123;% notel [颜色] [可选: 自定义图标] [标题] %&#125;内容支持换行&#123;% endnotel %&#125;\n\n\n\n\n参数\n说明\n可选值\n\n\n\n颜色\n提示块的样式或颜色\nblue red cyan purple orange yellow green等颜色\n\n\n自定义图标\n自定义图标，选填\nFontawsome 的图标名称后半部分，比如 fa-image\n\n\n例如\n&#123;% notel default fa-info 信息 %&#125;换行测试换行测试换行测试&#123;% endnotel %&#125;&#123;% notel blue 提示 %&#125;换行测试换行测试换行测试&#123;% endnotel %&#125;&#123;% notel red 自定义标题 %&#125;换行测试换行测试换行测试&#123;% endnotel %&#125;\n\n效果：\n\n  \n    \n      信息\n\n    \n    \n      换行测试换行测试换行测试\n\n    \n  \n\n\n  \n    \n      提示\n\n    \n    \n      换行测试换行测试换行测试\n\n    \n  \n\n\n  \n    \n      自定义标题\n\n    \n    \n      换行测试换行测试换行测试\n\n    \n  \n\nnote格式：\n&#123;% note [样式/颜色] [可选: 自定义图标] %&#125;笔记内容&#123;% endnote %&#125;\n\n\n\n\n参数\n说明\n可选值\n\n\n\n样式&#x2F;颜色\n提示块的样式或颜色\nsuccess default primary info warning danger tip question以及 blue red cyan purple orange yellow green等颜色\n\n\n自定义图标\n自定义图标，选填\nFontawsome 的图标名称后半部分，比如 fa-image\n\n\n具体例子如下\n&#123;% note  %&#125;默认 提示块标签&#123;% endnote %&#125;&#123;% note default  %&#125;default 提示块标签&#123;% endnote %&#125;&#123;% note primary  %&#125;primary 提示块标签&#123;% endnote %&#125;&#123;% note success  %&#125;success 提示块标签&#123;% endnote %&#125;&#123;% note info  %&#125;info 提示块标签&#123;% endnote %&#125;&#123;% note warning  %&#125;warning 提示块标签&#123;% endnote %&#125;&#123;% note danger  %&#125;danger 提示块标签&#123;% endnote %&#125;&#123;% note red fa-bolt%&#125;自定义提示块标签&#123;% endnote %&#125;\n\n效果：\n\n  \n    默认 提示块标签\n\n  \n\n\n  \n    default 提示块标签\n\n  \n\n\n  \n    primary 提示块标签\n\n  \n\n\n  \n    success 提示块标签\n\n  \n\n\n  \n    info 提示块标签\n\n  \n\n\n  \n    warning 提示块标签\n\n  \n\n\n  \n    danger 提示块标签\n\n  \n\n\n  \n    自定义提示块标签\n\n  \n\nbuttons写法格式：\n&#123;% btn [可选大小]::[名称]::[url]::[可选图标] %&#125;\n\n例如：\n不设置任何参数的 &#123;% btn 按钮:: / %&#125; 适合融入段落中。regular 按钮适合独立于段落之外：&#123;% btn regular::示例博客::https://www.ohevan.com::fa-solid fa-play-circle %&#125;&#123;% btn regular::示例博客::https://www.ohevan.com::fa-solid fa-play-circle %&#125;large 按钮更具有强调作用，建议搭配 center 使用：&#123;% btn center large::开始使用::https://redefine-docs.ohevan.com::fa-solid fa-download %&#125;\n\n不设置任何参数的 按钮 适合融入段落中。\nregular 按钮适合独立于段落之外：\n 示例博客\n\n 示例博客\n\nlarge 按钮更具有强调作用，建议搭配 center 使用：\n 开始使用\n\n变量可选值[可选大小] :\ncenter, regular, large, center large, center regular\n\n[可选图标] :\nFontawesome\n 图标名称，比如 fa-solid fa-house\nfloding写法&#123;% folding [颜色]::[标题] %&#125;需要写的内容&#123;% endfolding %&#125;\n\n例子\n&#123;% folding blue::Folding 测试： 点击查看更多 %&#125;啊啊啊啊啊&#123;% note danger  %&#125;danger 提示块标签&#123;% endnote %&#125;&#123;% note tip  %&#125;tip 提示块标签&#123;% endnote %&#125;&#123;% endfolding %&#125;\n\n\n    Folding 测试： 点击查看更多 \n    \n      啊啊啊啊啊\n  \n    danger 提示块标签\n\n  \n\n\n  \n    tip 提示块标签\n\n  \n\n    \n  \n\n颜色列表yellow, blue, green, red, orange, pink, cyan, white, black, gray\n\ntabs写法使用 Tabs 模块需要在 markdown 中按照以下格式编写：\n&#123;% tabs 页面内不重复的ID %&#125;&lt;!-- tab 栏目1名称 --&gt;内容&lt;!-- endtab --&gt;&lt;!-- tab 栏目2名称 --&gt;内容&lt;!-- endtab --&gt;&#123;% endtabs %&#125;\n\n其中，页面内不重复的ID 为你为这个选项卡创建的唯一标识符，可以随便取。\n每个栏目内容使用 &lt;!-- tab 栏目名称 --&gt; 和 &lt;!-- endtab --&gt; 来定义。\n例子：\n&#123;% tabs First unique name %&#125;&lt;!-- tab First Tab--&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab Second Tab--&gt;**This is Tab 2.**This is Tab 2.&lt;!-- endtab --&gt;&lt;!-- tab Third Tab--&gt;**This is Tab 3.**This is Tab 3.This is Tab 3.&lt;!-- endtab --&gt;&#123;% endtabs %&#125;\n\nFirst TabSecond TabThird TabThis is Tab 1.This is Tab 2.\nThis is Tab 2.This is Tab 3.\nThis is Tab 3.\nThis is Tab 3.\n","tags":["start"]},{"title":"博客搭建（五）配置gitalk评论功能","url":"/2024/01/09/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%94%EF%BC%89%E9%85%8D%E7%BD%AEgitalk%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/","content":"\n  \n    [2024-10-24] 更新：本站点评论系统已更换为 waline。\n\n  \n\n\n\n  \n    适用于hexo博客，使用hexo-theme-Redefine主题。参阅博客搭建（一）建站。\n\n  \n\n1. 注册github应用首先需要注册一个github应用：\n\n其中Homepage URL和Authorization callback URL都填写博客的域名即可。\n点击Register application后，会生成一个Client ID和一个Client Secret，没有Client Secret的话点击Generate a new client secret即可，这两个值在后面会用到。\n2. 新建一个仓库在github上新建一个 public 仓库，用于存放评论数据。随便发布一个 issue 用于开启 issues。\n3. 修改配置修改 _config.redefine.yml 文件的相关配置：\ncomment:  # Whether to enable comment  enable: true  # Comment system  system: gitalk # waline, gitalk, twikoo, giscus  # System configuration  config:    # Gitalk comment system. See https://github.com/gitalk/gitalk    gitalk:      clientID: # GitHub Application Client ID      clientSecret: # GitHub Application Client Secret      repo:  # GitHub repository      owner: # GitHub repository owner      proxy: https://cors-anywhere.null-qwerty.top/?https://github.com/login/oauth/access_token # CORS Proxy\n\nclientID 和 clientSecret 是第一步注册应用时生成的两个值，repo 是第二步新建的仓库的名称，owner 是仓库的拥有者，一般是自己的用户名。proxy 是一个代理，用于解决跨域问题，由于经常被墙，所以可能需要更换。可以在gitalk的issues里找到可能可用的代理，上面配置中是我个人搭建的一个代理，可以试试。\n4. 可能遇到的问题\n未找到相关的 issues 进行评论，请联系 @xxx 初始化创建：点一下下面的使用 github 登录按钮即可。如果在部署 gitalk 之前发布过文章，则需要登录后将每篇文章刷新一下，才能正常使用评论功能。\nError: Not Found：没找到仓库，检查名称是否正确。\nError: Network Error：网络错误，检查代理是否可用。\n\n","tags":["start"]},{"title":"博客搭建（四）Cloudflare配置","url":"/2023/12/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E5%9B%9B%EF%BC%89Cloudflare%E9%85%8D%E7%BD%AE/","content":"之前使用 Cloudflare 的免费 CDN 服务，但是效果不是很好，查阅资料发现可以通过配置一些选项来加速国内访问速度。\n配置的思路：尽可能让 CDN 保存多的文件。\n速度打开 Cloudflare 仪表盘，左边选择速度→优化→内容优化\n\n设置 Rocket Loader 为 ON，Auto Minify 勾选所有的文件类型\n\n\n  \n    后续发现 Rocket Loader 会导致页面的一些 JS 代码失效，故关闭该功能。\n\n  \n\n缓存打开 Cloudflare 仪表盘，左边选择缓存→配置\n\n设置 Always Online 为 On，开发模式 为 OFF\n\n其他保持默认即可。\n页面规则打开 Cloudflare 仪表盘，左边选择规则→页面规则，免费版只能添加三条规则，不过对于个人博客来说足够了。\n\n页面规则的配置比较随意，可以根据自己的需求来设置，笔者的配置如下：\n\n\n至此配置完成。通过测（乐）速（子）网站的测试，国内访问速度有了明显的提升。\n\n","tags":["Cloudflare","start"]},{"title":"理解贝叶斯定理","url":"/2023/10/10/%E7%90%86%E8%A7%A3%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86/","content":"首先贴一下百度百科上贝叶斯定理的简介：\n\n贝叶斯定理由英国数学家贝叶斯 ( Thomas Bayes 1702-1761 ) 发展，用来描述两个条件概率之间的关系，比如  和 。按照乘法法则，可以立刻导出\n\n如上公式也可变形为\n\n\n什么是贝叶斯定理在贝叶斯定理之前，我们先来认识全概率公式：\n\n设  是样本空间  的一个划分，且 ，则对  的任一事件 ，有\n\n假设，有\n\n根据乘法定理，上式可改写为\n\n式被称为 全概率公式.\n\n根据全概率公式和条件概率的定义，可以推出贝叶斯定理：\n\n即\n在贝叶斯定理【式】中，每个名词都有约定俗成的名称：是的先验概率或边缘概率。之所以称为”先验”是因为它不考虑任何方面的因素。是已知发生后的条件概率，也由于得自的取值而被称作的后验概率。是已知发生后的条件概率，也由于得自的取值而被称作的后验概率。是的先验概率或边缘概率，也作标准化常量（normalized constant）。用这些术语，贝叶斯定理可以表述为：后验概率相似度先验概率标准化常量\n\n其中的相似度指，比例相似度标准化常量被称为标准相似度，或可能性函数，由此贝叶斯定理可以表示为：后验概率标准相似度可能性函数先验概率\n\n可能性函数是一个调整因子，也就是新信息带来的调整，作用是将先验概率调整到更接近真实概率。\n可能性函数，表明新信息增强了的真实性。可能性函数，表明新信息对的真实性没有影响。可能性函数，表明新信息减弱了的真实性。\n\n\n贝叶斯定理能做什么逆概率问题贝叶斯定理的产生是为了计算“逆概率”问题，比如：\n\n已知某疾病患病概率为，某检测方法的准确率为，误报率为，某人检测结果为阳性，求该人患病的概率。\n\n设为患病，为检测结果为阳性，则：于是我们得到：即该人患病的概率约为。这也是检测患病人群要多次检测的原因。\n机器学习中的应用贝叶斯定理是一种推理方法，它与人脑的工作机制很像，这一特征让贝叶斯定理成为机器学习的基础。\n贝叶斯定理的性质，使得它能够将先验知识和新证据结合起来，形成新的知识，这让它对于那些需要在庞大数据库中进行数据匹配的问题非常有效。\n例如，我们可以用贝叶斯定理来进行垃圾邮件的过滤。我们可以先从大量的邮件中学习出一些关键词，比如“药物”、“银行”、“免费”、“领奖”等等，然后根据这些关键词来判断一封邮件是否是垃圾邮件。这里，关键词就是先验知识，而新邮件中是否包含这些关键词就是新证据，我们可以根据贝叶斯定理来计算一封邮件是垃圾邮件的概率。\n或者制作一个拼写检查器。\n","tags":["数学","概率论与数理统计"]},{"title":"第一篇博客","url":"/2023/10/05/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","content":"严格的说这并不是第一篇博客，因为在这之前还有 Hexo自动生成的一篇 hello-world ，笔者不打算删除那篇文章，还把建站时间定成了那篇文章的发布时间，因为它是在项目构建的时候生成的，能让建站时间更长（笑）\n发展历史笔者很早就有建个人博客的想法，但因为 能力不足 懒，迟迟没有上手操作。最近有点上头了，在网上找了教程，花两个小时建了一个简单的博客——就是你现在浏览的这个网站。\n建站的3202年，跟微博、微信朋友圈，甚至QQ空间对比，网络博客好像是一种过时的东西（大概？）。它维护起来更麻烦，内容似乎也更正式，不太能跟上越来越快的生活节奏。笔者建立这个博客的初心，是记录学习到的知识，方便以后作为资料站使用。\n博客内容\n计算机相关知识的学习经历及成果。\n如你所见，笔者是个 沙峦 二次元，大概也会发些相关内容，比如galgame的短评&#x2F;中评&#x2F;长评（虽然一篇都没写过）。\n欧皇晒卡\n其它想发的内容。\n\n虽然上文说博客的内容似乎更正式，但实际上挺随意的。\n版权声明本博客全部内容（除特别声明外）均采用 CC BY-NC-SA 4.0 协议进行许可。\n","tags":["start"]},{"title":"记录一次使用ros时产生的段错误","url":"/2023/10/21/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8ros%E6%97%B6%E4%BA%A7%E7%94%9F%E7%9A%84%E6%AE%B5%E9%94%99%E8%AF%AF/","content":"问题描述最近在修改项目中与下位机的通信协议时，抛出了一个段错误。调试找到该错误出现在下面这行代码：\nros::NodeHandle nh_;\n显然这个错误是不正常的，因为所有的ros包中都需要这个对象，而且这个对象在其他地方都是正常的。经过分析，发现问题出在#pragma pack(1)上面。\n问题分析为了保证通信协议结构体的长度等于内部成员的长度之和，我在通信协议结构体定义前加上了#pragma pack(1)：\n#pragma pack(1)     // 对齐长度 1 字节，即不对齐typedef struct Protocol_s&#123;    uint8_t start;    uint8_t type;    uint8_t buffer[29];    uint8_t end;&#125;\n防止内存对齐，保证结构体长度一定是32字节。\n同时，我将包含通信协议的头文件放在了ros的头文件前面：\n#include &quot;protocol.h&quot;// 省略其他头文件#include &lt;ros/ros.h&gt;\n在编译时，编译器会将头文件中的内容拷贝到源文件中，因此#pragma pack(1)也会被拷贝到源文件中，并且在ros.h的前面，对ros中的相关结构定义产生影响。猜测ros中为了保证速率，会直接对内存进行操作，而这些操作考虑了内存对齐的问题，因此在取消内存对齐后这些操作会出现非法访问，导致段错误。\n解决方案\n将自定义的头文件放在ros的头文件后面，这样#pragma pack(1)就不会影响ros的结构体定义。\n在结构体定义后面加上#pragma pack()，还原内存对齐：#pragma pack(1)     // 对齐长度 1 字节，即不对齐typedef struct Protocol_s&#123;    uint8_t start;    uint8_t type;    uint8_t buffer[29];    uint8_t end;&#125;#pragma pack()    // 还原内存对齐\n\n","tags":["C/C++","ros","段错误"]},{"title":"提问的智慧","url":"/2023/10/26/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/","content":"\n  \n    本文修改自 https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md\n\n  \n\n\nHow To Ask Questions The Smart Way\nCopyright © 2001,2006,2014 Eric S. Raymond, Rick Moen\n本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。\n原文网址：http://www.catb.org/~esr&#x2F;faqs&#x2F;smart-questions.html\nCopyleft 2001 by D.H.Grand(nOBODY&#x2F;Ginux), 2010 by Gasolin, 2015 by Ryan Wu\n本中文指南是基于原文 3.10 版以及 2010 年由 Gasolin 所翻译版本的最新翻译；\n协助指出翻译问题，请发 issue，或直接发 pull request 给我。\n声明许多项目在他们网站的帮助文档中链接了本指南。这很好，这正是我们想要的用途。但如果你是该项目管理员并试图创建指向本指南的超链接，请在超链接附近的显著位置注明：\n本指南不提供此项目的实际支持服务！\n我们已经深刻领教到缺少上述声明所带来的痛苦：我们将不停地被那些认为发布这本指南就意味着有责任解决世上所有技术问题的傻瓜苦苦纠缠。\n如果你因寻求某些帮助而阅读本指南，并在离开时还觉得可以从本文作者这里得到直接帮助，那你就是我们之前说的那些傻瓜之一。别问我们问题，我们只会忽略你。我们在这本指南中想教你如何从那些真正懂得你所遇到的软件或硬件问题的人处取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。\n简介在黑客的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确地提问以获得你满意的答案。\n现在开源（Open Source）软件已经相当盛行，您通常可以从其他更有经验的用户那里获得与黑客一样好的答案，这是件好事；和黑客相比，用户们往往对那些新手常遇到的问题更宽容一些。尽管如此，以我们在此推荐的方式对待这些有经验的用户通常也是从他们那里获得有用答案的最有效方式。\n首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，“好问题！”是诚挚的大力称赞。\n尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。\n我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 失败者（撸瑟） （由于历史原因，我们有时把它拼作 lusers）。\n我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们认可这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们只为那些真正有兴趣并愿意积极参与问题解决的人调整回答问题的风格。这点不会变，也不该变：否则，我们就是在最擅长的事情上降低效率。\n我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情地滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效地利用时间来回答赢家（winner）的问题。\n如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。\n所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 —— 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。\n如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 —— 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。\n（欢迎对本指南提出改进意见。你可以把你的建议发送至 esr@thyrsus.com 或 respond-auto@linuxmafia.com。然而请注意，本文并非网络礼节的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。\n在提问之前在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：\n\n尝试在你准备提问的论坛的旧文章中搜索答案。\n尝试上网搜索以找到答案。\n尝试阅读手册以找到答案。\n尝试阅读常见问题文件（FAQ）以找到答案。\n尝试自己检查或试验以找到答案。\n向你身边的强者朋友打听以找到答案。\n如果你是程序开发者，请尝试阅读源代码以找到答案。\n\n当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所学到的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。\n运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（搜索 Google 论坛和网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 我在 Google 中搜过下列句子但没有找到什么有用的东西 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。\n别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐得舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。\n准备好你的问题，再将问题仔细地思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。\n小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着蠢问题…，一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。\n绝不要自以为够格得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去挣到一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动地从他人处索取知识。\n另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。谁能给点提示？、我的这个例子里缺了什么？以及我应该检查什么地方比请把我需要的确切的过程贴出来更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。\n当你提问时慎选提问的论坛小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：\n\n在与主题不合的论坛上贴出你的问题。\n在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。\n在太多的不同新闻群组上重复转贴同样的问题（cross-post）。\n向既非熟人也没有义务解决你问题的人发送私人电邮。\n\n黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。\n因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括阅读 FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。\n向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 —— 如果你不确定，那就向别处发送，或者压根别发。\n在选择论坛、新闻群组或邮件列表时，别太相信它的名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。\n别像机关枪似的一次“扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。\n搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。\n一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。\n可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者由于涌入其私人邮箱的大量不堪忍受的无用邮件而不再提供支持。\nStack Overflow搜索，然后在 Stack Exchange 问。\n近年来，Stack Exchange 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。\n因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的几率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。\n如果你还是找不到任何对你的问题有用的内容，请把你的问题发在与它最相关的网站上。提问的时候请善用格式化工具，尤其注意为代码添加格式，并且添加相关的标签（特别是编程语言、操作系统或库&#x2F;包的名称）。当有人要求你提供更多相关信息时，请编辑你的贴子来补充它们[译注：而不是发一个回帖或回答！]。如果你觉得一个答案对你有帮助，点击向上的箭头来为它投票；如果一个答案提供了问题的正确解决方案，点击投票按钮下方的对勾来将它标记为正解。\nStack Exchange 已经成长到超过一百个网站，以下是最常用的几个站：\n\nSuper User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。\nStack Overflow 是问写程序有关的问题。\nServer Fault 是问服务器和网管相关的问题。\n\n网站和 IRC 论坛本地的用户群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表），这些都是开始提问的好地方，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。\n事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复“使用我们的版本”。\n在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。\n通过论坛或 IRC 频道来提供用户支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。\n在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。\n第二步，使用项目邮件列表当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：\n\n任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，那这也不能成为骚扰个别开发者的理由。\n向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。\n大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其他人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。\n如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。\n\n如果一个项目既有“用户”也有“开发者”（或“黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向“用户”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。\n然而，如果你确信你的问题很特别，而且在“用户”列表或论坛中几天都没有回复，可以试试前往“开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）\n如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。\n使用有意义且描述明确的标题在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的帮帮忙、跪求、急（更别说救命啊！！！！这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。\n一个好标题范例是目标 —— 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。\n\n蠢问题：救命啊！我的笔记本电脑不能正常显示了！\n\n\n聪明问题：X.org 6.8.1 的鼠标指针会变形，某牌显卡 MV1005 芯片组。\n\n\n更聪明问题：X.org 6.8.1 的鼠标指针，在某牌显卡 MV1005 芯片组环境下 - 会变形。\n\n编写目标 —— 差异 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标指针或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境和你遇到的问题。\n总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。\n如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 Re: 测试 或者 Re: 新 bug 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。\n对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许用户按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。\n仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。\n在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你只想在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。\n使问题容易回复以请将你的回复发送到……来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，换个好点的；如果是操作系统不支持这种邮件程序，也换个好点的。\n在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如追踪此讨论串、有回复时发送邮件提醒等功能。\n使用清晰、正确、精准且合乎语法的语句我们从经验中发现，粗心的提问者通常也会粗心地写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。\n正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它必须很准确，而且有迹象表明你是在思考和关注问题。\n正确地拼写、使用标点和大小写，不要将its混淆为it&#39;s，loose搞成lose或者将discrete弄成discreet。不要全部用大写，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。Alan Cox 也许可以这样做，但你不行）。\n更白话的说，如果你写得像是个半文盲[译注：小白]，那多半得不到理睬。也不要使用即时通信中的简写或火星文，如将的简化为d会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。\n如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂的语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。\n如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：[译注：以下附上原文以供使用]\n\nEnglish is not my native language; please excuse typing errors.\n\n\n英文不是我的母语，请原谅我的错字或语法。\n\n\nIf you speak $LANGUAGE, please email&#x2F;PM me;I may need assistance translating my question.\n\n\n如果你说某语言，请向我发电邮&#x2F;私信；\n我需要有人协助我翻译我的问题。\n\n\nI am familiar with the technical terms,but some slang expressions and idioms are difficult for me.\n\n\n我对技术名词很熟悉，但对于俗语或是特别用法不甚了解。\n\n\nI’ve posted my question in $LANGUAGE and English.I’ll be glad to translate responses, if you only use one or the other.\n\n\n我把我的问题用某语言和英文写出来。\n如果你只用其中的一种语言回答，我会乐意将回复翻译成为你使用的语言。\n\n使用易于读取且标准的文件格式发送问题如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：\n\n使用纯文字而不是 HTML (关闭 HTML 并不难）。\n使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。\n不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。\n但是，对一些特殊的文件不要设置固定宽度（譬如日志文件拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。\n在英语论坛中，不要使用Quoted-Printable MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的=20符号既难看也分散注意力，甚至有可能破坏内容的语意。\n绝对，永远不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。\n如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的智能引号功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉智能引号单选框），以免在你的邮件中到处散布垃圾字符。\n在论坛，勿滥用表情符号和HTML功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。\n\n如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的查看源代码命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。\n精确地描述问题并言之有物\n仔细、清楚地描述你的问题或 Bug 的症状。\n描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。\n描述在提问前你是怎样去研究和理解这个问题的。\n描述在提问前为确定问题而采取的诊断步骤。\n描述最近做过什么可能相关的硬件或软件变更。\n尽可能地提供一个可以重现这个问题的可控环境的方法。\n\n尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能提出的问题回答一遍。\n以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。\nSimon Tatham 写过一篇名为《如何有效地报告Bug》的出色文章。强力推荐你也读一读。\n话不在多而在精你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。\n这样做的用处至少有三点。第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；第二，简化问题使你更有可能得到有用的答案；第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。\n别动辄声称找到 Bug当你在使用软件中遇到问题，除非你非常、非常的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的Bug，你应该能提供相应位置的修正或替代文件。\n请记得，还有其他许多用户没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前已经做了这些，是吧？）。这也意味着很有可能是你弄错了而不是软件本身有问题。\n编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有Bug时，这尤其严重。\n提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是你做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。\n低声下气不能代替你的功课有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：我知道我只是个可悲的新手，一个撸瑟，但...。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。\n别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。\n有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。\n描述问题症状而非你的猜测告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。\n蠢问题\n\n我在编译内核时接连遇到 SIG11 错误，我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？\n\n聪明问题\n\n我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6&#x2F;233 CPU（威盛 Apollo VP2 芯片组），256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。所有内存都换过了，没有效果。相关部分的标准编译记录如下…\n\n由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：所有的诊断专家都来自密苏里州。 美国国务院的官方座右铭则是：让我看看（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方地展示给我们看吧！\n按发生时间先后列出问题症状问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。\n如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，多不等于好。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。\n如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。\n描述目标而不是过程如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。\n经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。\n蠢问题\n\n我怎样才能从某绘图程序的颜色选择器中取得十六进制的 RGB 值？\n\n聪明问题\n\n我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），但却无法从某绘图程序的颜色选择器取得十六进制的 RGB 值。\n\n第二种提问法比较聪明，你可能得到像是建议采用另一个更合适的工具的回复。\n别要求使用私人电邮回复黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。\n当你要求私下回复时，这个过程和奖励都被中止。别这样做，让回复者来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于不可能使其他人产生兴趣。\n这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是向我发电邮，我将为论坛归纳这些回复。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。\n清楚明确地表达你的问题以及需求漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。\n如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。\n要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。\n所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你获得有用的答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问我想更好地理解 X，可否指点一下哪有好一点说明？通常比问你能解释一下 X 吗？更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。\n询问有关代码的问题时如果没有提示别人应该从何入手，别要求他人帮你调试有问题的代码。张贴几百行的代码，然后说一声：它不能工作会让你完全被忽略。只贴几十行代码，然后说一句：在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;比较有可能让你得到回应。\n最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能刚好展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译&#x2F;直译&#x2F;被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看话不在多而在精一节）。\n一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做是一个好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。\n如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。\n别把自己家庭作业的问题贴上来黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由你来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。\n如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户群组，论坛或（最后一招）在项目的用户邮件列表或论坛中提问。尽管黑客们会看出来，但一些有经验的用户也许仍会给你一些提示。\n去掉无意义的提问句避免用无意义的话结束提问，例如有人能帮我吗？或者这有答案吗？。\n首先：如果你对问题的描述不是很好，这样问更是画蛇添足。\n其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：没错，有人能帮你或者不，没答案。\n一般来说，避免用 是或否、对或错、有或没有类型的问句，除非你想得到是或否类型的回答。\n即使你很急也不要在标题写紧急这是你的问题，不是我们的。宣称紧急极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，紧急这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。\n有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。\n当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如紧急：帮我救救这个毛茸茸的小海豹！肯定让你被黑客忽略或惹恼他们，即使他们认为毛茸茸的小海豹很重要。\n如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。\n礼多人不怪，而且有时还很有帮助彬彬有礼，多用请和谢谢您的关注，或谢谢你的关照。让大家都知道你对他们花时间免费提供帮助心存感激。\n坦白说，这一点并没有比使用清晰、正确、精准且合乎语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）\n然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。\n（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得先谢了意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说先谢了，然后事后再对回复者表示感谢，或者换种方式表达感激，譬如用谢谢你的关注或谢谢你的关照。）\n问题解决后，加个简短的补充说明问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。\n最理想的方式是向最初提问的话题回复此消息，并在标题中包含已修正，已解决或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串问题 X和问题 X - 已解决的潜在回复者就明白不用再浪费时间了（除非他个人觉得问题 X有趣），因此可以利用此时间去解决其它问题。\n补充说明不必很长或是很深入；简单的一句你好，原来是网线出了问题！谢谢大家 – Bill比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。\n对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此之后才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。\n除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表&#x2F;新闻群组&#x2F;论坛中搜索到真正解决你问题的方案，让他们也从中受益。\n至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。\n思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。\n在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。\n如何解读答案\nRTFM 和 STFW：如何知道你已完全搞砸了有一个古老而神圣的传统：如果你收到RTFM（Read The Fucking Manual）的回应，回答者认为你应该去读他妈的手册。当然，基本上他是对的，你应该去读一读。\nRTFM 有一个年轻的亲戚。如果你收到STFW（Search The Fucking Web）的回应，回答者认为你应该到他妈的网上搜索。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 Google 是你的朋友！）\n在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。\n通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为：\n\n你需要的信息非常容易获得；\n你自己去搜索这些信息比灌给你，能让你学到更多。\n\n你不应该因此不爽；依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见。你应该对他祖母般的慈祥表示感谢。\n如果还是搞不懂如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。\n比方说，如果我回答你：看来似乎是 zentry 卡住了；你应该先清除它。，然后，这是一个很糟的后续问题回应：zentry 是什么？ 好的问法应该是这样：哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？\n处理无礼的回应很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直截了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。\n如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这没有发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而你将被视为有错的一方，这将伤害到你获取信息或帮助的机会。\n另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。\n（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会正常交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们喜欢我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑。）\nJeff Bigler 的观察总结和这个相关也值得一读 (tact filters)。\n在下一节，我们会谈到另一个问题，当你行为不当时所会受到的冒犯。\n如何避免扮演失败者在黑客社区的论坛中，你以本指南所描述的或类似的方式，可能会有那么几次搞砸了。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。\n这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被言语攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、不去关马桶盖等等。相反地，你该这么做：\n熬过去，这很正常。事实上，它是有益健康且合理的。\n社区的标准不会自行维持，它们是通过参与者积极而公开地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。\n也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称如果你不想帮助用户就闭嘴。 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。\n夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。\n记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。\n有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是真的会把问题搞砸。\n这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。\n也别让自己卷入口水战，最好不要理睬大多数的口水战 —— 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。\n不该问的问题以下是几个经典蠢问题，以及黑客没回答时心中所想的：\n问题：我能在哪找到 X 程序或 X 资源？\n问题：我怎样用 X 做 Y？\n问题：如何设定我的 shell 提示？\n问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？\n问题：我的程序&#x2F;设定&#x2F;SQL 语句没有用\n问题：我的 Windows 电脑有问题，你能帮我吗？\n问题：我的程序不会动了，我认为系统工具 X 有问题\n问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？\n问题：我怎么才能破解 root 帐号&#x2F;窃取 OP 特权&#x2F;读别人的邮件呢？\n\n\n\n问题：我能在哪找到 X 程序或 X 资源？\n\n回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 Google 吗？\n\n\n问题：我怎样用 X 做 Y？\n\n回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。\n\n\n问题：如何设定我的 shell 提示？？\n\n回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 RTFM，然后自己去找出来。\n\n\n问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？\n\n回答：试试看就知道了。如果你试过，你就知道了答案，就不用浪费我的时间了。\n\n\n问题：我的{程序&#x2F;设定&#x2F;SQL 语句}没有用\n\n回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种\n\n你还有什么要补充的吗？\n真糟糕，希望你能搞定。\n这关我屁事？\n\n\n\n问题：我的 Windows 电脑有问题，你能帮我吗？\n\n回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。\n注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你可以问与 Windows 相关的问题，只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。\n\n\n问题：我的程序不会动了，我认为系统工具 X 有问题\n\n回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。\n\n\n问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？\n\n回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在这儿找到用户群组的清单）。\n注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地用户群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 Linux 和所有被怀疑的硬件作关键词仔细搜索。\n\n\n问题：我怎么才能破解 root 帐号&#x2F;窃取 OP 特权&#x2F;读别人的邮件呢？\n\n回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！\n好问题与蠢问题最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。\n蠢问题：\n\n我可以在哪儿找到关于 Foonly Flurbamatic 的资料？\n\n这种问法无非想得到 STFW 这样的回答。\n聪明问题：\n\n我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？\n\n这个问题已经 STFW 过了，看起来他真的遇到了麻烦。\n蠢问题：\n\n我从 foo 项目找来的源码没法编译。它怎么这么烂？\n\n他觉得都是别人的错，这个傲慢自大的提问者。\n聪明问题：\n\nfoo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？\n\n提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。\n蠢问题：\n\n我的主机板有问题了，谁来帮我？\n\n某黑客对这类问题的回答通常是：好的，还要帮你拍拍背和换尿布吗？，然后按下删除键。\n聪明问题：\n\n我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？\n\n这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。\n在最后一个问题中，注意告诉我答案和给我启示，指出我还应该做什么诊断工作之间微妙而又重要的区别。\n事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。\n通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。\n事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候，一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的名人，而是因为我用了正确的方式来提问。\n黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我像个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。\n如果得不到回答如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。\n总的来说，简单地重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。\n你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。\n有许多网上的以及本地的用户群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。\n另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。\n对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名用户。根本不可能由一个人来处理来自上万名用户的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。\n如何更好地回答问题态度和善一点。 问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。\n对初犯者私下回复。 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。\n如果你不确定，一定要说出来！ 一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。\n如果帮不了忙，也别妨碍他。 不要在实际步骤上开玩笑，那样也许会毁了提问者的设置 —— 有些可怜的呆瓜会把它当成真的指令。\n试探性的反问以引出更多的细节。 如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。\n尽管对那些懒虫抱怨一声 RTFM 是正当的，但能给出文档的链接（即使只是建议个 Google 搜索关键词）会更好。\n如果你决定回答，就请给出好的答案。 当别人正在用错误的工具或方法时别建议笨拙的权宜之计（workaround），应推荐更好的工具，重新界定问题。\n正面地回答问题！ 如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 试试看 A 或是 B 或者 试试 X 、 Y 、 Z 、 A 、 B 、 C 并附上一个链接一点用都没有。\n帮助你的社区从问题中学习。 当回复一个好问题时，问问自己如何修改相关文件或常见问题文件以免再次解答同样的问题？，接着再向文件维护者发一份补丁。\n如果你在研究一番后才作出了回答，展现你的技巧而不是直接端出结果。毕竟授人以鱼不如授人以渔。\n相关资源如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 Unix 系统和网络基本原理。\n当你发布软件或补丁时，试着按软件发布实践操作。\n鸣谢Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写如何更好地回答问题这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。\n","tags":["计算机"]}]